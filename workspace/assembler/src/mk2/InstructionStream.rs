/// An instruction stream.
pub trait InstructionStream
{
	/// Add with carry imm8 to `AL`.
	fn adc_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Add with carry imm16 to `AX`.
	fn adc_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// Add with carry imm32 to `EAX`.
	fn adc_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// Add with carry imm16 to r/m16.
	fn adc_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 to r/m16.
	fn adc_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Add with carry r16 to r/m16.
	fn adc_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Add with Carry Flag (CF) imm32 to r/m32.
	fn adc_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 into r/m32.
	fn adc_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Add with Carry Flag (CF) r32 to r/m32.
	fn adc_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Add with Carry Flag (CF) imm32 sign extended to 64-bits to r/m64.
	fn adc_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 into r/m64.
	fn adc_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Add with Carry Flag (CF) r64 to r/m64.
	fn adc_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Add with carry imm8 to r/m8.
	fn adc_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Add with carry byte register to r/m8.
	fn adc_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Add with carry byte register to r/m8.
	fn adc_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Add with carry imm16 to r/m16.
	fn adc_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 to r/m16.
	fn adc_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Add with carry r/m16 to r16.
	fn adc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Add with carry r16 to r/m16.
	fn adc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Add with carry r/m16 to r16.
	fn adc_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Add with Carry Flag (CF) imm32 to r/m32.
	fn adc_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 into r/m32.
	fn adc_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Add with Carry Flag (CF) r/m32 to r32.
	fn adc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Add with Carry Flag (CF) r32 to r/m32.
	fn adc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Add with Carry Flag (CF) r/m32 to r32.
	fn adc_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Add with Carry Flag (CF) imm32 sign extended to 64-bits to r/m64.
	fn adc_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Add with Carry Flag (CF) sign-extended imm8 into r/m64.
	fn adc_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Add with Carry Flag (CF) r/m64 to r64.
	fn adc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Add with Carry Flag (CF) r64 to r/m64.
	fn adc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Add with Carry Flag (CF) r/m64 to r64.
	fn adc_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Add with carry imm8 to r/m8.
	fn adc_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Add with carry byte register to r/m8.
	fn adc_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Add with carry byte register to r/m8.
	fn adc_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add with carry imm32 sign extended to 64-bits to RAX.
	fn adc_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// Add with carry imm8 to r/m8.
	fn adc_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Add with carry byte register to r/m8.
	fn adc_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Add with carry byte register to r/m8.
	fn adc_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add with carry r/m8 to byte register.
	fn adc_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add imm8 to AL.
	fn add_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Add imm16 to AX.
	fn add_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// Add imm32 to EAX.
	fn add_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// Add imm16 to r/m16.
	fn add_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Add sign-extended imm8 to r/m16.
	fn add_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Add r16 to r/m16.
	fn add_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Add imm32 to r/m32.
	fn add_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Add sign-extended imm8 to r/m32.
	fn add_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Add r32 to r/m32.
	fn add_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Add imm32 sign-extended to 64-bits to r/m64.
	fn add_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Add sign-extended imm8 to r/m64.
	fn add_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Add r64 to r/m64.
	fn add_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Add imm8 to r/m8.
	fn add_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Add r8 to r/m8.
	fn add_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Add r8 to r/m8.
	fn add_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Add imm16 to r/m16.
	fn add_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Add sign-extended imm8 to r/m16.
	fn add_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Add r/m16 to r16.
	fn add_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Add r16 to r/m16.
	fn add_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Add r/m16 to r16.
	fn add_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Add imm32 to r/m32.
	fn add_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Add sign-extended imm8 to r/m32.
	fn add_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Add r/m32 to r32.
	fn add_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Add r32 to r/m32.
	fn add_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Add r/m32 to r32.
	fn add_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Add imm32 sign-extended to 64-bits to r/m64.
	fn add_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Add sign-extended imm8 to r/m64.
	fn add_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Add r/m64 to r64.
	fn add_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Add r64 to r/m64.
	fn add_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Add r/m64 to r64.
	fn add_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Add imm8 to r/m8.
	fn add_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Add r/m8 to r8.
	fn add_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Add r8 to r/m8.
	fn add_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Add r/m8 to r8.
	fn add_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Add r8 to r/m8.
	fn add_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add r/m8 to r8.
	fn add_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add imm32 sign-extended to 64-bits to RAX.
	fn add_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// Add imm8 to r/m8.
	fn add_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Add r/m8 to r8.
	fn add_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Add r8 to r/m8.
	fn add_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Add r/m8 to r8.
	fn add_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Add r8 to r/m8.
	fn add_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add r/m8 to r8.
	fn add_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Add packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn addpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn addpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
	fn addps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
	fn addps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add the low double-precision floating-point value from xmm2/m64 to xmm1.
	fn addsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Add the low double-precision floating-point value from xmm2/m64 to xmm1.
	fn addsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add the low single-precision floating-point value from xmm2/m32 to xmm1.
	fn addss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Add the low single-precision floating-point value from xmm2/m32 to xmm1.
	fn addss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.
	fn addsubpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.
	fn addsubpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.
	fn addsubps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.
	fn addsubps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesdec_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesdec_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesdeclast_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesdeclast_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesenc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesenc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesenclast_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.
	fn aesenclast_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
	fn aesimc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
	fn aesimc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
	fn aeskeygenassist_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
	fn aeskeygenassist_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// AL AND imm8.
	fn and_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// AX AND imm16.
	fn and_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// EAX AND imm32.
	fn and_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// r/m16 AND imm16.
	fn and_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// r/m16 AND imm8 (sign-extended).
	fn and_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// r/m16 AND r16.
	fn and_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// r/m32 AND imm32.
	fn and_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// r/m32 AND imm8 (sign-extended).
	fn and_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// r/m32 AND r32.
	fn and_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// r/m64 AND imm32 sign extended to 64-bits.
	fn and_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// r/m64 AND imm8 (sign-extended).
	fn and_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// r/m64 AND r32.
	fn and_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// r/m8 AND imm8.
	fn and_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// r/m8 AND r8.
	fn and_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// r/m8 AND r8.
	fn and_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// r/m16 AND imm16.
	fn and_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// r/m16 AND imm8 (sign-extended).
	fn and_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// r16 AND r/m16.
	fn and_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// r/m16 AND r16.
	fn and_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r16 AND r/m16.
	fn and__Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r/m32 AND imm32.
	fn and_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// r/m32 AND imm8 (sign-extended).
	fn and_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// r32 AND r/m32.
	fn and_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// r/m32 AND r32.
	fn and_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r32 AND r/m32.
	fn and__Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r/m64 AND imm32 sign extended to 64-bits.
	fn and_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// r/m64 AND imm8 (sign-extended).
	fn and_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// r64 AND r/m64.
	fn and_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// r/m64 AND r32.
	fn and_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r64 AND r/m64.
	fn and__Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r/m8 AND imm8.
	fn and_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// r8 AND r/m8.
	fn and_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// r/m8 AND r8.
	fn and_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r8 AND r/m8.
	fn and__Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r/m8 AND r8.
	fn and_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 AND r/m8.
	fn and__Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// RAX AND imm32 sign-extended to 64-bits.
	fn and_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// r/m8 AND imm8.
	fn and_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// r8 AND r/m8.
	fn and_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// r/m8 AND r8.
	fn and_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r8 AND r/m8.
	fn and__RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r/m8 AND r8.
	fn and_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 AND r/m8.
	fn and__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Bitwise AND of inverted r32b with r/m32, store result in r32a.
	fn andn_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory);

	/// Bitwise AND of inverted r32b with r/m32, store result in r32a.
	fn andn_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Bitwise AND of inverted r64b with r/m64, store result in r64a.
	fn andn_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory);

	/// Bitwise AND of inverted r64b with r/m64, store result in r64a.
	fn andn_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Bitwise logical AND NOT of xmm2/m128 and xmm1.
	fn andnpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise logical AND NOT of xmm2/m128 and xmm1.
	fn andnpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Bitwise logical AND NOT of xmm2/m128 and xmm1.
	fn andnps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise logical AND NOT of xmm2/m128 and xmm1.
	fn andnps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
	fn andpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
	fn andpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Bitwise logical AND of xmm2/m128 and xmm1.
	fn andps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise logical AND of xmm2/m128 and xmm1.
	fn andps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.
	fn bextr_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit);

	/// Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.
	fn bextr_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a.
	fn bextr_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit);

	/// Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a.
	fn bextr_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn blendpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn blendpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn blendps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn blendps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
	fn blendvpd_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0);

	/// Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
	fn blendvpd_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0);

	/// Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
	fn blendvps_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0);

	/// Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
	fn blendvps_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0);

	/// Extract lowest set bit from r/m32 and set that bit in r32.
	fn blsi_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Extract lowest set bit from r/m32 and set that bit in r32.
	fn blsi_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Extract lowest set bit from r/m64, and set that bit in r64.
	fn blsi_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Extract lowest set bit from r/m64, and set that bit in r64.
	fn blsi_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Set all lower bits in r32 to "1" starting from bit 0 to lowest set bit in r/m32.
	fn blsmsk_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Set all lower bits in r32 to "1" starting from bit 0 to lowest set bit in r/m32.
	fn blsmsk_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Set all lower bits in r64 to "1" starting from bit 0 to lowest set bit in r/m64.
	fn blsmsk_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Set all lower bits in r64 to "1" starting from bit 0 to lowest set bit in r/m64.
	fn blsmsk_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.
	fn blsr_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.
	fn blsr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.
	fn blsr_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.
	fn blsr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Bit scan forward on r/m16.
	fn bsf_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Bit scan forward on r/m16.
	fn bsf_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Bit scan forward on r/m32.
	fn bsf_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Bit scan forward on r/m32.
	fn bsf_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Bit scan forward on r/m64.
	fn bsf_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Bit scan forward on r/m64.
	fn bsf_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Bit scan reverse on r/m16.
	fn bsr_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Bit scan reverse on r/m16.
	fn bsr_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Bit scan reverse on r/m32.
	fn bsr_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Bit scan reverse on r/m32.
	fn bsr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Bit scan reverse on r/m64.
	fn bsr_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Bit scan reverse on r/m64.
	fn bsr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Reverses the byte order of a 32-bit register.
	fn bswap_Register32Bit(&mut self, arg0: Register32Bit);

	/// Reverses the byte order of a 64-bit register.
	fn bswap_Register64Bit(&mut self, arg0: Register64Bit);

	/// Store selected bit in CF flag.
	fn bt_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Store selected bit in CF flag.
	fn bt_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Store selected bit in CF flag.
	fn bt_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Store selected bit in CF flag.
	fn bt_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Store selected bit in CF flag.
	fn bt_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Store selected bit in CF flag.
	fn bt_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag.
	fn bt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and complement.
	fn btc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and clear.
	fn btr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Store selected bit in CF flag and set.
	fn bts_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Zero bits in r/m32 starting with the position in r32b, write result to r32a.
	fn bzhi_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit);

	/// Zero bits in r/m32 starting with the position in r32b, write result to r32a.
	fn bzhi_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Zero bits in r/m64 starting with the position in r64b, write result to r64a.
	fn bzhi_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit);

	/// Zero bits in r/m64 starting with the position in r64b, write result to r64a.
	fn bzhi_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Call far, absolute indirect address given in m16:16.
	/// In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16- bit offset from far pointer referenced in the instruction.
	fn call_FarPointer16BitTo16Bit(&mut self, arg0: FarPointer16BitTo16Bit);

	/// In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.
	fn call_FarPointer16BitTo32Bit(&mut self, arg0: FarPointer16BitTo32Bit);

	/// In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.
	fn call_FarPointer16BitTo64Bit(&mut self, arg0: FarPointer16BitTo64Bit);

	/// Call near, relative, displacement relative to next instruction.
	/// 32-bit displacement sign extended to 64-bits in 64-bit mode.
	fn call_Label(&mut self, arg0: Label);

	/// Call near, absolute indirect, address given in r/m64.
	fn call_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Call near, absolute indirect, address given in r/m64.
	fn call_Register64Bit(&mut self, arg0: Register64Bit);

	/// Call near, relative, displacement relative to next instruction.
	/// 32-bit displacement sign extended to 64-bits in 64-bit mode.
	fn call_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// AX = sign-extend of AL.
	fn cbw(&mut self);

	/// `EDX:EAX` = sign-extend of EAX.
	fn cdq(&mut self);

	/// RAX = sign-extend of EAX.
	fn cdqe(&mut self);

	/// Clear CF flag.
	fn clc(&mut self);

	/// Clear DF flag.
	fn cld(&mut self);

	/// Flushes cache line containing m8.
	fn clflush_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Clear interrupt flag; interrupts disabled when interrupt flag cleared.
	fn cli(&mut self);

	/// Complement CF flag.
	fn cmc(&mut self);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmova_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if above or equal (Carry Flag (CF) is 0).
	fn cmovae_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if below (Carry Flag (CF) is 1).
	fn cmovb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovbe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if carry (Carry Flag (CF) is 1).
	fn cmovc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn cmove_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if greater or equal (`SF == OF`).
	fn cmovge_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if less (SF != OF).
	fn cmovl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if less (SF != OF).
	fn cmovl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if less (`SF != OF`).
	fn cmovl_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if less (`SF != OF`).
	fn cmovl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if less (`SF != OF`).
	fn cmovl_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if less (`SF != OF`).
	fn cmovl_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovle_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn cmovna_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not above or equal (Carry Flag (CF) is 1).
	fn cmovnae_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not below (Carry Flag (CF) is 0).
	fn cmovnb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn cmovnbe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not carry (Carry Flag (CF) is 0).
	fn cmovnc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn cmovne_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn cmovng_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not greater or equal (`SF != OF`).
	fn cmovnge_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not less (`SF == OF`).
	fn cmovnl_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn cmovnle_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not overflow (OF=0).
	fn cmovno_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not overflow (OF=0).
	fn cmovno_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not overflow (OF=0).
	fn cmovno_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not overflow (OF=0).
	fn cmovno_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not overflow (OF=0).
	fn cmovno_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not overflow (OF=0).
	fn cmovno_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not parity (Parity Flag (PF) is 0).
	fn cmovnp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not sign (Sign Flag (SF) is 0).
	fn cmovns_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if not zero (Zero Flag (ZF) is 0).
	fn cmovnz_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if overflow (Overflow Flag (OF) is 1).
	fn cmovo_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if parity (Parity Flag (PF) is 1).
	fn cmovp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if parity even (Parity Flag (PF) is 1).
	fn cmovpe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if parity odd (Parity Flag (PF) is 0).
	fn cmovpo_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if sign (SF=1).
	fn cmovs_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if sign (SF=1).
	fn cmovs_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if sign (SF=1).
	fn cmovs_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if sign (SF=1).
	fn cmovs_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if sign (SF=1).
	fn cmovs_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if sign (SF=1).
	fn cmovs_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move if zero (Zero Flag (ZF) is 1).
	fn cmovz_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Compare imm8 with AL.
	fn cmp_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Compare imm16 with AX.
	fn cmp_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// Compare imm32 with EAX.
	fn cmp_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// Compare imm16 with r/m16.
	fn cmp_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Compare imm8 with r/m16.
	fn cmp_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Compare r16 with r/m16.
	fn cmp_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Compare imm32 with r/m32.
	fn cmp_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Compare imm8 with r/m32.
	fn cmp_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Compare r32 with r/m32.
	fn cmp_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Compare imm32 sign-extended to 64-bits with r/m64.
	fn cmp_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Compare imm8 with r/m64.
	fn cmp_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Compare r64 with r/m64.
	fn cmp_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Compare imm8 with r/m8.
	fn cmp_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Compare r8 with r/m8.
	fn cmp_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Compare r8 with r/m8.
	fn cmp_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare imm16 with r/m16.
	fn cmp_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Compare imm8 with r/m16.
	fn cmp_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Compare r/m16 with r16.
	fn cmp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Compare r16 with r/m16.
	fn cmp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Compare r/m16 with r16.
	fn cmp_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Compare imm32 with r/m32.
	fn cmp_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Compare imm8 with r/m32.
	fn cmp_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Compare r/m32 with r32.
	fn cmp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Compare r32 with r/m32.
	fn cmp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Compare r/m32 with r32.
	fn cmp_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Compare imm32 sign-extended to 64-bits with r/m64.
	fn cmp_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Compare imm8 with r/m64.
	fn cmp_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Compare r/m64 with r64.
	fn cmp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Compare r64 with r/m64.
	fn cmp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Compare r/m64 with r64.
	fn cmp_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Compare imm8 with r/m8.
	fn cmp_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Compare r/m8 with r8.
	fn cmp_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Compare r8 with r/m8.
	fn cmp_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Compare r/m8 with r8.
	fn cmp_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Compare r8 with r/m8.
	fn cmp_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare r/m8 with r8.
	fn cmp_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare imm32 sign-extended to 64-bits with RAX.
	fn cmp_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// Compare imm8 with r/m8.
	fn cmp_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Compare r/m8 with r8.
	fn cmp_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Compare r8 with r/m8.
	fn cmp_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Compare r/m8 with r8.
	fn cmp_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Compare r8 with r/m8.
	fn cmp_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare r/m8 with r8.
	fn cmp_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
	fn cmppd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
	fn cmppd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
	fn cmpps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
	fn cmpps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory);

	/// For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory);

	/// Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
	fn cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory);

	/// For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmps_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64- bit mode compare byte at address (R|E)SI with byte at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmpsb(&mut self);

	/// For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmpsd(&mut self);

	/// Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
	fn cmpsd_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
	fn cmpsd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.
	fn cmpsq(&mut self);

	/// Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
	fn cmpss_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
	fn cmpss_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64- bit mode compare word at address (R|E)SI with word at address (R|E)DI.
	/// The status flags are set accordingly.
	fn cmpsw(&mut self);

	/// Compare AX with r/m16.
	/// If equal, ZF is set and r16 is loaded into r/m16.
	/// Else, clear ZF and load r/m16 into AX.
	fn cmpxchg_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Compare EAX with r/m32.
	/// If equal, ZF is set and r32 is loaded into r/m32.
	/// Else, clear ZF and load r/m32 into EAX.
	fn cmpxchg_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Compare RAX with r/m64.
	/// If equal, ZF is set and r64 is loaded into r/m64.
	/// Else, clear ZF and load r/m64 into RAX.
	fn cmpxchg_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare AX with r/m16.
	/// If equal, ZF is set and r16 is loaded into r/m16.
	/// Else, clear ZF and load r/m16 into AX.
	fn cmpxchg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Compare EAX with r/m32.
	/// If equal, ZF is set and r32 is loaded into r/m32.
	/// Else, clear ZF and load r/m32 into EAX.
	fn cmpxchg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Compare RAX with r/m64.
	/// If equal, ZF is set and r64 is loaded into r/m64.
	/// Else, clear ZF and load r/m64 into RAX.
	fn cmpxchg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Compare AL with r/m8.
	/// If equal, ZF is set and r8 is loaded into r/m8.
	/// Else, clear ZF and load r/m8 into AL.
	fn cmpxchg_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare `RDX:RAX` with m128.
	/// If equal, set ZF and load RCX:RBX into m128.
	/// Else, clear ZF and load m128 into `RDX:RAX`.
	fn cmpxchg16b_Any128BitMemory(&mut self, arg0: Any128BitMemory);

	/// Compare `EDX:EAX` with m64.
	/// If equal, set ZF and load ECX:EBX into m64.
	/// Else, clear ZF and load m64 into `EDX:EAX`.
	fn cmpxchg8b_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn comisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn comisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn comiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn comiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
	fn cpuid(&mut self);

	/// `RDX:RAX` = sign-extend of RAX.
	fn cqo(&mut self);

	/// Accumulate CRC32 on r/m16.
	fn crc32_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// Accumulate CRC32 on r/m32.
	fn crc32_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Accumulate CRC32 on r/m8.
	fn crc32_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory);

	/// Accumulate CRC32 on r/m16.
	fn crc32_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit);

	/// Accumulate CRC32 on r/m32.
	fn crc32_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Accumulate CRC32 on r/m8.
	fn crc32_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit);

	/// Accumulate CRC32 on r/m8.
	fn crc32_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Accumulate CRC32 on r/m64.
	fn crc32_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Accumulate CRC32 on r/m8.
	fn crc32_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory);

	/// Accumulate CRC32 on r/m64.
	fn crc32_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Accumulate CRC32 on r/m8.
	fn crc32_Register64Bit_Register8Bit(&mut self, arg0: Register64Blit, arg1: Register8Bit);

	/// Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
	fn cvtdq2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
	fn cvtdq2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
	fn cvtdq2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
	fn cvtdq2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
	fn cvtpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
	fn cvtpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm.
	fn cvtpd2pi_MmRegister_Any128BitMemory(&mut self, arg0: MmRegister, arg1: Any128BitMemory);

	/// Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm.
	fn cvtpd2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister);

	/// Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
	fn cvtpd2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
	fn cvtpd2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.
	fn cvtpi2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.
	fn cvtpi2pd_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister);

	/// Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.
	fn cvtpi2ps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.
	fn cvtpi2ps_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister);

	/// Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
	fn cvtps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
	fn cvtps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
	fn cvtps2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
	fn cvtps2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm.
	fn cvtps2pi_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm.
	fn cvtps2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
	fn cvtsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
	fn cvtsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
	fn cvtsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
	fn cvtsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
	fn cvtsd2ss_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
	fn cvtsd2ss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
	fn cvtsi2sd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
	fn cvtsi2sd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
	fn cvtsi2sd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit);

	/// Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
	fn cvtsi2sd_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit);

	/// Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
	fn cvtsi2ss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
	fn cvtsi2ss_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
	fn cvtsi2ss_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit);

	/// Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
	fn cvtsi2ss_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit);

	/// Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
	fn cvtss2sd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
	fn cvtss2sd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
	fn cvtss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
	fn cvtss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
	fn cvtss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
	fn cvtss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
	fn cvttpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
	fn cvttpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.
	fn cvttpd2pi_MmRegister_Any128BitMemory(&mut self, arg0: MmRegister, arg1: Any128BitMemory);

	/// Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.
	fn cvttpd2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister);

	/// Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
	fn cvttps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
	fn cvttps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.
	fn cvttps2pi_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.
	fn cvttps2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
	fn cvttsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory);

	/// Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
	fn cvttsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
	fn cvttsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
	fn cvttsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
	fn cvttss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
	fn cvttss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
	fn cvttss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
	fn cvttss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// DX:AX = sign-extend of AX.
	fn cwd(&mut self);

	/// EAX = sign-extend of AX.
	fn cwde(&mut self);

	/// Decrement r/m16 by 1.
	fn dec_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Decrement r/m32 by 1.
	fn dec_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Decrement r/m64 by 1.
	fn dec_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Decrement r/m8 by 1.
	fn dec_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Decrement r/m16 by 1.
	fn dec_Register16Bit(&mut self, arg0: Register16Bit);

	/// Decrement r/m32 by 1.
	fn dec_Register32Bit(&mut self, arg0: Register32Bit);

	/// Decrement r/m64 by 1.
	fn dec_Register64Bit(&mut self, arg0: Register64Bit);

	/// Decrement r/m8 by 1.
	fn dec_Register8Bit(&mut self, arg0: Register8Bit);

	/// Decrement r/m8 by 1.
	fn dec_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
	fn div_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Unsigned divide `EDX:EAX` by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
	fn div_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Unsigned divide `RDX:RAX` by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
	fn div_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
	fn div_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
	fn div_Register16Bit(&mut self, arg0: Register16Bit);

	/// Unsigned divide `EDX:EAX` by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
	fn div_Register32Bit(&mut self, arg0: Register32Bit);

	/// Unsigned divide `RDX:RAX` by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
	fn div_Register64Bit(&mut self, arg0: Register64Bit);

	/// Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
	fn div_Register8Bit(&mut self, arg0: Register8Bit);

	/// Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
	fn div_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
	fn divpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
	fn divpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
	fn divps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
	fn divps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
	fn divsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
	fn divsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
	fn divss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
	fn divss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
	fn dppd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
	fn dppd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
	fn dpps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
	fn dpps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Set the x87 FPU tag word to empty.
	fn emms(&mut self);

	/// Create a nested stack frame for a procedure.
	fn enter_Immediate8Bit_Immediate16Bit(&mut self, arg0: Immediate8Bit, arg1: Immediate16Bit);

	/// Create a nested stack frame for a procedure.
	fn enter_One_Immediate16Bit(&mut self, arg0: One, arg1: Immediate16Bit);

	/// Create a stack frame for a procedure.
	fn enter_Zero_Immediate16Bit(&mut self, arg0: Zero, arg1: Immediate16Bit);

	/// Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32.
	/// The upper 32 bits of r64 is zeroed if reg is r64.
	fn extractps_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32.
	/// The upper 32 bits of r64 is zeroed if reg is r64.
	fn extractps_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32.
	/// The upper 32 bits of r64 is zeroed if reg is r64.
	fn extractps_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Replace ST(0) with (2^(ST(0)) - 1).
	fn f2xm1(&mut self);

	/// Replace ST with its absolute value.
	fn fabs(&mut self);

	/// Add m32fp to ST(0) and store result in ST(0).
	fn fadd_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Add m64fp to ST(0) and store result in ST(0).
	fn fadd_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Add ST(i) to ST(0) and store result in ST(i).
	fn fadd_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Add ST(0) to ST(i) and store result in ST(0).
	fn fadd_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Add ST(0) to ST(1), store result in ST(1), and pop the register stack.
	fn faddp(&mut self);

	/// Add ST(0) to ST(i), store result in ST(i), and pop the register stack.
	fn faddp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Convert BCD value to floating-point and push onto the FPU stack.
	fn fbld_X87BinaryCodedDecimal80BitMemory(&mut self, arg0: X87BinaryCodedDecimal80BitMemory);

	/// Store ST(0) in m80bcd and pop ST(0).
	fn fbstp_X87BinaryCodedDecimal80BitMemory(&mut self, arg0: X87BinaryCodedDecimal80BitMemory);

	/// Complements sign of ST(0).
	fn fchs(&mut self);

	/// Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.
	fn fclex(&mut self);

	/// Move if below (Carry Flag (CF) is 1).
	fn fcmovb_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn fcmovbe_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if equal (Zero Flag (ZF) is 1).
	fn fcmove_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if not below (Carry Flag (CF) is 0).
	fn fcmovnb_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn fcmovnbe_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if not equal (Zero Flag (ZF) is 0).
	fn fcmovne_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if not unordered (Parity Flag (PF) is 0).
	fn fcmovnu_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Move if unordered (Parity Flag (PF) is 1).
	fn fcmovu_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Compare ST(0) with ST(1).
	fn fcom(&mut self);

	/// Compare ST(0) with m32fp.
	fn fcom_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Compare ST(0) with m64fp.
	fn fcom_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Compare ST(0) with ST(i).
	fn fcom_X87Register(&mut self, arg0: X87Register);

	/// Compare ST(0) with ST(i) and set status flags accordingly.
	fn fcomi_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.
	fn fcomip_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Compare ST(0) with ST(1) and pop register stack.
	fn fcomp(&mut self);

	/// Compare ST(0) with m32fp and pop register stack.
	fn fcomp_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Compare ST(0) with m64fp and pop register stack.
	fn fcomp_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Compare ST(0) with ST(i) and pop register stack.
	fn fcomp_X87Register(&mut self, arg0: X87Register);

	/// Compare ST(0) with ST(1) and pop register stack twice.
	fn fcompp(&mut self);

	/// Replace ST(0) with its cosine.
	fn fcos(&mut self);

	/// Decrement TOP field in FPU status word.
	fn fdecstp(&mut self);

	/// Divide ST(0) by m32fp and store result in ST(0).
	fn fdiv_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.
	fn fdiv_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Divide ST(i) by ST(0) and store result in ST(i).
	fn fdiv_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Divide ST(0) by ST(i) and store result in ST(0).
	fn fdiv_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.
	fn fdivp(&mut self);

	/// Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.
	fn fdivp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Divide m32fp by ST(0) and store result in ST(0).
	fn fdivr_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Divide m64fp by ST(0) and store result in ST(0).
	fn fdivr_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Divide ST(0) by ST(i) and store result in ST(i).
	fn fdivr_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Divide ST(i) by ST(0) and store result in ST(0).
	fn fdivr_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.
	fn fdivrp(&mut self);

	/// Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.
	fn fdivrp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Sets tag for ST(i) to empty.
	fn ffree_X87Register(&mut self, arg0: X87Register);

	/// Add m16int to ST(0) and store result in ST(0).
	fn fiadd_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Add m32int to ST(0) and store result in ST(0).
	fn fiadd_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Compare ST(0) with m16int.
	fn ficom_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Compare ST(0) with m32int.
	fn ficom_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Compare ST(0) with m16int and pop stack register.
	fn ficomp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Compare ST(0) with m32int and pop stack register.
	fn ficomp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Divide ST(0) by m64int and store result in ST(0).
	fn fidiv_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Divide ST(0) by m32int and store result in ST(0).
	fn fidiv_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Divide m16int by ST(0) and store result in ST(0).
	fn fidivr_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Divide m32int by ST(0) and store result in ST(0).
	fn fidivr_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Push m16int onto the FPU register stack.
	fn fild_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Push m32int onto the FPU register stack.
	fn fild_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Push m64int onto the FPU register stack.
	fn fild_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory);

	/// Multiply ST(0) by m16int and store result in ST(0).
	fn fimul_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Multiply ST(0) by m32int and store result in ST(0).
	fn fimul_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Increment the TOP field in the FPU status register.
	fn fincstp(&mut self);

	/// Initialize FPU after checking for pending unmasked floating-point exceptions.
	fn finit(&mut self);

	/// Store ST(0) in m16int.
	fn fist_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Store ST(0) in m32int.
	fn fist_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Store ST(0) in m16int and pop register stack.
	fn fistp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Store ST(0) in m32int and pop register stack.
	fn fistp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Store ST(0) in m64int and pop register stack.
	fn fistp_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory);

	/// Store ST(0) in m16int with truncation.
	fn fisttp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Store ST(0) in m32int with truncation.
	fn fisttp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Store ST(0) in m64int with truncation.
	fn fisttp_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory);

	/// Subtract m16int from ST(0) and store result in ST(0).
	fn fisub_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Subtract m32int from ST(0) and store result in ST(0).
	fn fisub_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Subtract ST(0) from m16int and store result in ST(0).
	fn fisubr_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory);

	/// Subtract ST(0) from m32int and store result in ST(0).
	fn fisubr_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory);

	/// Push m32fp onto the FPU register stack.
	fn fld_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Push m64fp onto the FPU register stack.
	fn fld_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Push m80fp onto the FPU register stack.
	fn fld_X87Float80BitMemory(&mut self, arg0: X87Float80BitMemory);

	/// Push ST(i) onto the FPU register stack.
	fn fld_X87Register(&mut self, arg0: X87Register);

	/// Push +1.0 onto the FPU register stack.
	fn fld1(&mut self);

	/// Load FPU control word from m2byte.
	fn fldcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory);

	/// Load FPU environment from m14byte or m28byte.
	fn fldenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory);

	/// Push log2e onto the FPU register stack.
	fn fldl2e(&mut self);

	/// Push log210 onto the FPU register stack.
	fn fldl2t(&mut self);

	/// Push log102 onto the FPU register stack.
	fn fldlg2(&mut self);

	/// Push loge2 onto the FPU register stack.
	fn fldln2(&mut self);

	/// Push pi onto the FPU register stack.
	fn fldpi(&mut self);

	/// Push +0.0 onto the FPU register stack.
	fn fldz(&mut self);

	/// Multiply ST(0) by m32fp and store result in ST(0).
	fn fmul_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Multiply ST(0) by m64fp and store result in ST(0).
	fn fmul_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Multiply ST(i) by ST(0) and store result in ST(i).
	fn fmul_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Multiply ST(0) by ST(i) and store result in ST(0).
	fn fmul_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.
	fn fmulp(&mut self);

	/// Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.
	fn fmulp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.
	fn fnclex(&mut self);

	/// Initialize FPU without checking for pending unmasked floating-point exceptions.
	fn fninit(&mut self);

	/// No operation is performed.
	fn fnop(&mut self);

	/// Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions.
	/// Then re-initialize the FPU.
	fn fnsave_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory);

	/// Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.
	fn fnstcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory);

	/// Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions.
	/// Then mask all floating-point exceptions.
	fn fnstenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory);

	/// Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.
	fn fnstsw_AX(&mut self, arg0: AX);

	/// Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.
	fn fnstsw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory);

	/// Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.
	fn fpatan(&mut self);

	/// Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).
	fn fprem(&mut self);

	/// Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).
	fn fprem1(&mut self);

	/// Replace ST(0) with its tangent and push 1 onto the FPU stack.
	fn fptan(&mut self);

	/// Round ST(0) to an integer.
	fn frndint(&mut self);

	/// Load FPU state from m94byte or m108byte.
	fn frstor_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory);

	/// Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions.
	/// Then re-initialize the FPU.
	fn fsave_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory);

	/// Scale ST(0) by ST(1).
	fn fscale(&mut self);

	/// Replace ST(0) with its sine.
	fn fsin(&mut self);

	/// Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack.
	fn fsincos(&mut self);

	/// Computes square root of ST(0) and stores the result in ST(0).
	fn fsqrt(&mut self);

	/// Copy ST(0) to m32fp.
	fn fst_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Copy ST(0) to m64fp.
	fn fst_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Copy ST(0) to ST(i).
	fn fst_X87Register(&mut self, arg0: X87Register);

	/// Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.
	fn fstcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory);

	/// Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions.
	/// Then mask all floating-point exceptions.
	fn fstenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory);

	/// Copy ST(0) to m32fp and pop register stack.
	fn fstp_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Copy ST(0) to m64fp and pop register stack.
	fn fstp_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Copy ST(0) to m80fp and pop register stack.
	fn fstp_X87Float80BitMemory(&mut self, arg0: X87Float80BitMemory);

	/// Copy ST(0) to ST(i) and pop register stack.
	fn fstp_X87Register(&mut self, arg0: X87Register);

	/// Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.
	fn fstsw_AX(&mut self, arg0: AX);

	/// Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.
	fn fstsw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory);

	/// Subtract m32fp from ST(0) and store result in ST(0).
	fn fsub_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Subtract m64fp from ST(0) and store result in ST(0).
	fn fsub_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Subtract ST(0) from ST(i) and store result in ST(i).
	fn fsub_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Subtract ST(i) from ST(0) and store result in ST(0).
	fn fsub_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.
	fn fsubp(&mut self);

	/// Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.
	fn fsubp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Subtract ST(0) from m32fp and store result in ST(0).
	fn fsubr_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory);

	/// Subtract ST(0) from m64fp and store result in ST(0).
	fn fsubr_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory);

	/// Subtract ST(i) from ST(0) and store result in ST(i).
	fn fsubr_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Subtract ST(0) from ST(i) and store result in ST(0).
	fn fsubr_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.
	fn fsubrp(&mut self);

	/// Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.
	fn fsubrp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0);

	/// Compare ST(0) with 0.0.
	fn ftst(&mut self);

	/// Compare ST(0) with ST(1).
	fn fucom(&mut self);

	/// Compare ST(0) with ST(i).
	fn fucom_X87Register(&mut self, arg0: X87Register);

	/// Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.
	fn fucomi_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.
	fn fucomip_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register);

	/// Compare ST(0) with ST(1) and pop register stack.
	fn fucomp(&mut self);

	/// Compare ST(0) with ST(i) and pop register stack.
	fn fucomp_X87Register(&mut self, arg0: X87Register);

	/// Compare ST(0) with ST(1) and pop register stack twice.
	fn fucompp(&mut self);

	/// Check pending unmasked floating-point exceptions.
	fn fwait(&mut self);

	/// Classify value or number in ST(0).
	fn fxam(&mut self);

	/// Exchange the contents of ST(0) and ST(1).
	fn fxch(&mut self);

	/// Exchange the contents of ST(0) and ST(i).
	fn fxch_X87Register(&mut self, arg0: X87Register);

	/// Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.
	fn fxrstor_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory);

	/// Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.
	fn fxrstor64_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory);

	/// Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
	fn fxsave_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory);

	/// Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.
	fn fxsave64_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory);

	/// Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.
	fn fxtract(&mut self);

	/// Replace ST(1) with (ST(1) * log2ST(0)) and pop the register stack.
	fn fyl2x(&mut self);

	/// Replace ST(1) with ST(1) * log2(ST(0) + 1.0) and pop the register stack.
	fn fyl2xp1(&mut self);

	/// Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn haddpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn haddpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn haddps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn haddps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn hsubpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn hsubpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn hsubps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn hsubps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
	fn idiv_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Signed divide `EDX:EAX` by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
	fn idiv_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Signed divide `RDX:RAX` by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
	fn idiv_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
	fn idiv_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
	fn idiv_Register16Bit(&mut self, arg0: Register16Bit);

	/// Signed divide `EDX:EAX` by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
	fn idiv_Register32Bit(&mut self, arg0: Register32Bit);

	/// Signed divide `RDX:RAX` by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
	fn idiv_Register64Bit(&mut self, arg0: Register64Bit);

	/// Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
	fn idiv_Register8Bit(&mut self, arg0: Register8Bit);

	/// Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
	fn idiv_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// DX:AX = AX * r/m word.
	fn imul_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// `EDX:EAX` = EAX * r/m32.
	fn imul_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// `RDX:RAX` = RAX * r/m64.
	fn imul_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// AX= AL * r/m byte.
	fn imul_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// DX:AX = AX * r/m word.
	fn imul_Register16Bit(&mut self, arg0: Register16Bit);

	/// word register = word register * r/m16.
	fn imul_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// word register = r/m16 * immediate word.
	fn imul_Register16Bit_Any16BitMemory_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Any16BitMemory, arg2: Immediate16Bit);

	/// word register = r/m16 * sign-extended immediate byte.
	fn imul_Register16Bit_Any16BitMemory_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Any16BitMemory, arg2: Immediate8Bit);

	/// word register = word register * r/m16.
	fn imul_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// word register = r/m16 * immediate word.
	fn imul_Register16Bit_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate16Bit);

	/// word register = r/m16 * sign-extended immediate byte.
	fn imul_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit);

	/// `EDX:EAX` = EAX * r/m32.
	fn imul_Register32Bit(&mut self, arg0: Register32Bit);

	/// doubleword register = doubleword register *  r/m32.
	fn imul_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// doubleword register = r/m32 * immediate doubleword.
	fn imul_Register32Bit_Any32BitMemory_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate32Bit);

	/// doubleword register = r/m32 * sign- extended immediate byte.
	fn imul_Register32Bit_Any32BitMemory_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// doubleword register = doubleword register *  r/m32.
	fn imul_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// doubleword register = r/m32 * immediate doubleword.
	fn imul_Register32Bit_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate32Bit);

	/// doubleword register = r/m32 * sign- extended immediate byte.
	fn imul_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit);

	/// `RDX:RAX` = RAX * r/m64.
	fn imul_Register64Bit(&mut self, arg0: Register64Bit);

	/// Quadword register = Quadword register *  r/m64.
	fn imul_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Quadword register = r/m64 * immediate doubleword.
	fn imul_Register64Bit_Any64BitMemory_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate32Bit);

	/// Quadword register = r/m64 * sign-extended  immediate byte.
	fn imul_Register64Bit_Any64BitMemory_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Quadword register = Quadword register *  r/m64.
	fn imul_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Quadword register = r/m64 * immediate doubleword.
	fn imul_Register64Bit_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate32Bit);

	/// Quadword register = r/m64 * sign-extended  immediate byte.
	fn imul_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit);

	/// AX = AL * r/m byte.
	fn imul_Register8Bit(&mut self, arg0: Register8Bit);

	/// AX = AL * r/m byte.
	fn imul_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Input byte from I/O port in DX into AL.
	fn in_AL_DX(&mut self, arg0: AL, arg1: DX);

	/// Input byte from imm8 I/O port address into AL.
	fn in_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Input word from I/O port in DX into AX.
	fn in_AX_DX(&mut self, arg0: AX, arg1: DX);

	/// Input word from imm8 I/O port address into AX.
	fn in_AX_Immediate8Bit(&mut self, arg0: AX, arg1: Immediate8Bit);

	/// Input doubleword from I/O port in DX into EAX.
	fn in_EAX_DX(&mut self, arg0: EAX, arg1: DX);

	/// Input dword from imm8 I/O port address into EAX.
	fn in_EAX_Immediate8Bit(&mut self, arg0: EAX, arg1: Immediate8Bit);

	/// Increment r/m word by 1.
	fn inc_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Increment r/m doubleword by 1.
	fn inc_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Increment r/m quadword by 1.
	fn inc_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Increment r/m byte by 1.
	fn inc_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Increment r/m word by 1.
	fn inc_Register16Bit(&mut self, arg0: Register16Bit);

	/// Increment r/m doubleword by 1.
	fn inc_Register32Bit(&mut self, arg0: Register32Bit);

	/// Increment r/m quadword by 1.
	fn inc_Register64Bit(&mut self, arg0: Register64Bit);

	/// Increment r/m byte by 1.
	fn inc_Register8Bit(&mut self, arg0: Register8Bit);

	/// Increment r/m byte by 1.
	fn inc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
	fn ins_Any16BitMemory_DX(&mut self, arg0: Any16BitMemory, arg1: DX);

	/// Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
	fn ins_Any32BitMemory_DX(&mut self, arg0: Any32BitMemory, arg1: DX);

	/// Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
	fn ins_Any8BitMemory_DX(&mut self, arg0: Any8BitMemory, arg1: DX);

	/// Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.
	fn insb(&mut self);

	/// Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
	fn insd(&mut self);

	/// Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
	fn insertps_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
	fn insertps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.
	fn insw(&mut self);

	/// Interrupt vector number specified by immediate byte.
	fn int_Immediate8Bit(&mut self, arg0: Immediate8Bit);

	/// Interrupt 3-trap to debugger.
	fn int_Three(&mut self, arg0: Three);

	/// Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128.
	fn invpcid_Register64Bit_Any128BitMemory(&mut self, arg0: Register64Bit, arg1: Any128BitMemory);

	/// Interrupt return (16-bit operand size).
	fn iret(&mut self);

	/// Interrupt return (32-bit operand size).
	fn iretd(&mut self);

	/// Interrupt return (64-bit operand size).
	fn iretq(&mut self);

	/// Jump short if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Label(&mut self, arg0: Label);

	/// Jump near if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Label_1(&mut self, arg0: Label);

	/// Jump short if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn ja_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if above or equal (Carry Flag (CF) is 0).
	fn jae_Label(&mut self, arg0: Label);

	/// Jump near if above or equal (Carry Flag (CF) is 0).
	fn jae_Label_1(&mut self, arg0: Label);

	/// Jump short if above or equal (Carry Flag (CF) is 0).
	fn jae_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if above or equal (Carry Flag (CF) is 0).
	fn jae_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if above or equal (Carry Flag (CF) is 0).
	fn jae_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if above or equal (Carry Flag (CF) is 0).
	fn jae_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if above or equal (Carry Flag (CF) is 0).
	fn jae_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if above or equal (Carry Flag (CF) is 0).
	fn jae_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if below (Carry Flag (CF) is 1).
	fn jb_Label(&mut self, arg0: Label);

	/// Jump near if below (Carry Flag (CF) is 1).
	fn jb_Label_1(&mut self, arg0: Label);

	/// Jump short if below (Carry Flag (CF) is 1).
	fn jb_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if below (Carry Flag (CF) is 1).
	fn jb_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if below (Carry Flag (CF) is 1).
	fn jb_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if below (Carry Flag (CF) is 1).
	fn jb_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if below (Carry Flag (CF) is 1).
	fn jb_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if below (Carry Flag (CF) is 1).
	fn jb_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Label(&mut self, arg0: Label);

	/// Jump near if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Label_1(&mut self, arg0: Label);

	/// Jump short if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jbe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if carry (Carry Flag (CF) is 1).
	fn jc_Label(&mut self, arg0: Label);

	/// Jump near if carry (Carry Flag (CF) is 1).
	fn jc_Label_1(&mut self, arg0: Label);

	/// Jump short if carry (Carry Flag (CF) is 1).
	fn jc_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if carry (Carry Flag (CF) is 1).
	fn jc_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if carry (Carry Flag (CF) is 1).
	fn jc_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if carry (Carry Flag (CF) is 1).
	fn jc_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if carry (Carry Flag (CF) is 1).
	fn jc_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if carry (Carry Flag (CF) is 1).
	fn jc_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if equal (Zero Flag (ZF) is 1).
	fn je_Label(&mut self, arg0: Label);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn je_Label_1(&mut self, arg0: Label);

	/// Jump short if equal (Zero Flag (ZF) is 1).
	fn je_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn je_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn je_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn je_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if equal (Zero Flag (ZF) is 1).
	fn je_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if equal (Zero Flag (ZF) is 1).
	fn je_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if ECX register is 0.
	fn jecxz_Label(&mut self, arg0: Label);

	/// Jump short if ECX register is 0.
	fn jecxz_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump short if ECX register is 0.
	fn jecxz_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if ECX register is 0.
	fn jecxz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Label(&mut self, arg0: Label);

	/// Jump near if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Label_1(&mut self, arg0: Label);

	/// Jump short if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jg_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if greater or equal (`SF == OF`).
	fn jge_Label(&mut self, arg0: Label);

	/// Jump near if greater or equal (`SF == OF`).
	fn jge_Label_1(&mut self, arg0: Label);

	/// Jump short if greater or equal (`SF == OF`).
	fn jge_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if greater or equal (`SF == OF`).
	fn jge_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if greater or equal (`SF == OF`).
	fn jge_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if greater or equal (`SF == OF`).
	fn jge_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if greater or equal (`SF == OF`).
	fn jge_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if greater or equal (`SF == OF`).
	fn jge_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if less (`SF != OF`).
	fn jl_Label(&mut self, arg0: Label);

	/// Jump near if less (`SF != OF`).
	fn jl_Label_1(&mut self, arg0: Label);

	/// Jump short if less (`SF != OF`).
	fn jl_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if less (`SF != OF`).
	fn jl_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if less (`SF != OF`).
	fn jl_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if less (`SF != OF`).
	fn jl_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if less (`SF != OF`).
	fn jl_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if less (`SF != OF`).
	fn jl_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Label(&mut self, arg0: Label);

	/// Jump near if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Label_1(&mut self, arg0: Label);

	/// Jump short if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jle_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump far, absolute indirect, address given in m16:16.
	fn jmp_FarPointer16BitTo16Bit(&mut self, arg0: FarPointer16BitTo16Bit);

	/// Jump far, absolute indirect, address given in m16:32.
	fn jmp_FarPointer16BitTo32Bit(&mut self, arg0: FarPointer16BitTo32Bit);

	/// Jump far, absolute indirect, address given in m16:64.
	fn jmp_FarPointer16BitTo64Bit(&mut self, arg0: FarPointer16BitTo64Bit);

	/// Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits.
	fn jmp_Label(&mut self, arg0: Label);

	/// Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits.
	fn jmp_Label_1(&mut self, arg0: Label);

	/// Jump near, absolute indirect, RIP = 64-Bit offset from register or memory.
	fn jmp_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Jump near, absolute indirect, RIP = 64-Bit offset from register or memory.
	fn jmp_Register64Bit(&mut self, arg0: Register64Bit);

	/// Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits.
	fn jmp_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits.
	fn jmp_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Label(&mut self, arg0: Label);

	/// Jump near if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Label_1(&mut self, arg0: Label);

	/// Jump short if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn jna_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Label(&mut self, arg0: Label);

	/// Jump near if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Label_1(&mut self, arg0: Label);

	/// Jump short if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not above or equal (Carry Flag (CF) is 1).
	fn jnae_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not below (Carry Flag (CF) is 0).
	fn jnb_Label(&mut self, arg0: Label);

	/// Jump near if not below (Carry Flag (CF) is 0).
	fn jnb_Label_1(&mut self, arg0: Label);

	/// Jump short if not below (Carry Flag (CF) is 0).
	fn jnb_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not below (Carry Flag (CF) is 0).
	fn jnb_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not below (Carry Flag (CF) is 0).
	fn jnb_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not below (Carry Flag (CF) is 0).
	fn jnb_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not below (Carry Flag (CF) is 0).
	fn jnb_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not below (Carry Flag (CF) is 0).
	fn jnb_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Label(&mut self, arg0: Label);

	/// Jump near if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Label_1(&mut self, arg0: Label);

	/// Jump short if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn jnbe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not carry (Carry Flag (CF) is 0).
	fn jnc_Label(&mut self, arg0: Label);

	/// Jump near if not carry (Carry Flag (CF) is 0).
	fn jnc_Label_1(&mut self, arg0: Label);

	/// Jump short if not carry (Carry Flag (CF) is 0).
	fn jnc_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not carry (Carry Flag (CF) is 0).
	fn jnc_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not carry (Carry Flag (CF) is 0).
	fn jnc_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not carry (Carry Flag (CF) is 0).
	fn jnc_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not carry (Carry Flag (CF) is 0).
	fn jnc_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not carry (Carry Flag (CF) is 0).
	fn jnc_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not equal (Zero Flag (ZF) is 0).
	fn jne_Label(&mut self, arg0: Label);

	/// Jump near if not equal (Zero Flag (ZF) is 0).
	fn jne_Label_1(&mut self, arg0: Label);

	/// Jump short if not equal (Zero Flag (ZF) is 0).
	fn jne_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not equal (Zero Flag (ZF) is 0).
	fn jne_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not equal (Zero Flag (ZF) is 0).
	fn jne_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not equal (Zero Flag (ZF) is 0).
	fn jne_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not equal (Zero Flag (ZF) is 0).
	fn jne_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not equal (Zero Flag (ZF) is 0).
	fn jne_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jng_Label(&mut self, arg0: Label);

	/// Jump near if not greater (Zero Flag (ZF) is 1 or SF != OF).
	fn jng_Label_1(&mut self, arg0: Label);

	/// Jump short if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jng_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not greater (Zero Flag (ZF) is 1 or SF != OF).
	fn jng_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not greater (Zero Flag (ZF) is 1 or SF != OF).
	fn jng_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not greater (Zero Flag (ZF) is 1 or SF != OF).
	fn jng_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jng_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn jng_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not greater or equal (`SF != OF`).
	fn jnge_Label(&mut self, arg0: Label);

	/// Jump near if not greater or equal (SF != OF).
	fn jnge_Label_1(&mut self, arg0: Label);

	/// Jump short if not greater or equal (`SF != OF`).
	fn jnge_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not greater or equal (SF != OF).
	fn jnge_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not greater or equal (SF != OF).
	fn jnge_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not greater or equal (SF != OF).
	fn jnge_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not greater or equal (`SF != OF`).
	fn jnge_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not greater or equal (`SF != OF`).
	fn jnge_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not less (`SF == OF`).
	fn jnl_Label(&mut self, arg0: Label);

	/// Jump near if not less (`SF == OF`).
	fn jnl_Label_1(&mut self, arg0: Label);

	/// Jump short if not less (`SF == OF`).
	fn jnl_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not less (`SF == OF`).
	fn jnl_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not less (`SF == OF`).
	fn jnl_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not less (`SF == OF`).
	fn jnl_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not less (`SF == OF`).
	fn jnl_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not less (`SF == OF`).
	fn jnl_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Label(&mut self, arg0: Label);

	/// Jump near if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Label_1(&mut self, arg0: Label);

	/// Jump short if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn jnle_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not overflow (OF=0).
	fn jno_Label(&mut self, arg0: Label);

	/// Jump near if not overflow (OF=0).
	fn jno_Label_1(&mut self, arg0: Label);

	/// Jump short if not overflow (OF=0).
	fn jno_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not overflow (OF=0).
	fn jno_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not overflow (OF=0).
	fn jno_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not overflow (OF=0).
	fn jno_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not overflow (OF=0).
	fn jno_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not overflow (OF=0).
	fn jno_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not parity (Parity Flag (PF) is 0).
	fn jnp_Label(&mut self, arg0: Label);

	/// Jump near if not parity (Parity Flag (PF) is 0).
	fn jnp_Label_1(&mut self, arg0: Label);

	/// Jump short if not parity (Parity Flag (PF) is 0).
	fn jnp_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not parity (Parity Flag (PF) is 0).
	fn jnp_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not parity (Parity Flag (PF) is 0).
	fn jnp_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not parity (Parity Flag (PF) is 0).
	fn jnp_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not parity (Parity Flag (PF) is 0).
	fn jnp_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not parity (Parity Flag (PF) is 0).
	fn jnp_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not sign (Sign Flag (SF) is 0).
	fn jns_Label(&mut self, arg0: Label);

	/// Jump near if not sign (Sign Flag (SF) is 0).
	fn jns_Label_1(&mut self, arg0: Label);

	/// Jump short if not sign (Sign Flag (SF) is 0).
	fn jns_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not sign (Sign Flag (SF) is 0).
	fn jns_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not sign (Sign Flag (SF) is 0).
	fn jns_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not sign (Sign Flag (SF) is 0).
	fn jns_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not sign (Sign Flag (SF) is 0).
	fn jns_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not sign (Sign Flag (SF) is 0).
	fn jns_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if not zero (Zero Flag (ZF) is 0).
	fn jnz_Label(&mut self, arg0: Label);

	/// Jump near if not zero (Zero Flag (ZF) is 0).
	fn jnz_Label_1(&mut self, arg0: Label);

	/// Jump short if not zero (Zero Flag (ZF) is 0).
	fn jnz_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not zero (Zero Flag (ZF) is 0).
	fn jnz_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if not zero (Zero Flag (ZF) is 0).
	fn jnz_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if not zero (Zero Flag (ZF) is 0).
	fn jnz_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if not zero (Zero Flag (ZF) is 0).
	fn jnz_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if not zero (Zero Flag (ZF) is 0).
	fn jnz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if overflow (Overflow Flag (OF) is 1).
	fn jo_Label(&mut self, arg0: Label);

	/// Jump near if overflow (Overflow Flag (OF) is 1).
	fn jo_Label_1(&mut self, arg0: Label);

	/// Jump short if overflow (Overflow Flag (OF) is 1).
	fn jo_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if overflow (Overflow Flag (OF) is 1).
	fn jo_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if overflow (Overflow Flag (OF) is 1).
	fn jo_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if overflow (Overflow Flag (OF) is 1).
	fn jo_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if overflow (Overflow Flag (OF) is 1).
	fn jo_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if overflow (Overflow Flag (OF) is 1).
	fn jo_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if parity (Parity Flag (PF) is 1).
	fn jp_Label(&mut self, arg0: Label);

	/// Jump near if parity (Parity Flag (PF) is 1).
	fn jp_Label_1(&mut self, arg0: Label);

	/// Jump short if parity (Parity Flag (PF) is 1).
	fn jp_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity (Parity Flag (PF) is 1).
	fn jp_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity (Parity Flag (PF) is 1).
	fn jp_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if parity (Parity Flag (PF) is 1).
	fn jp_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if parity (Parity Flag (PF) is 1).
	fn jp_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if parity (Parity Flag (PF) is 1).
	fn jp_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if parity even (Parity Flag (PF) is 1).
	fn jpe_Label(&mut self, arg0: Label);

	/// Jump near if parity even (Parity Flag (PF) is 1).
	fn jpe_Label_1(&mut self, arg0: Label);

	/// Jump short if parity even (Parity Flag (PF) is 1).
	fn jpe_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity even (Parity Flag (PF) is 1).
	fn jpe_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity even (Parity Flag (PF) is 1).
	fn jpe_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if parity even (Parity Flag (PF) is 1).
	fn jpe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if parity even (Parity Flag (PF) is 1).
	fn jpe_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if parity even (Parity Flag (PF) is 1).
	fn jpe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if parity odd (Parity Flag (PF) is 0).
	fn jpo_Label(&mut self, arg0: Label);

	/// Jump near if parity odd (Parity Flag (PF) is 0).
	fn jpo_Label_1(&mut self, arg0: Label);

	/// Jump short if parity odd (Parity Flag (PF) is 0).
	fn jpo_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity odd (Parity Flag (PF) is 0).
	fn jpo_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if parity odd (Parity Flag (PF) is 0).
	fn jpo_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if parity odd (Parity Flag (PF) is 0).
	fn jpo_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if parity odd (Parity Flag (PF) is 0).
	fn jpo_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if parity odd (Parity Flag (PF) is 0).
	fn jpo_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if RCX register is 0.
	fn jrcxz_Label(&mut self, arg0: Label);

	/// Jump short if RCX register is 0.
	fn jrcxz_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump short if RCX register is 0.
	fn jrcxz_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if RCX register is 0.
	fn jrcxz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if sign (SF=1).
	fn js_Label(&mut self, arg0: Label);

	/// Jump near if sign (SF=1).
	fn js_Label_1(&mut self, arg0: Label);

	/// Jump short if sign (SF=1).
	fn js_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if sign (SF=1).
	fn js_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if sign (SF=1).
	fn js_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if sign (SF=1).
	fn js_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if sign (SF=1).
	fn js_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if sign (SF=1).
	fn js_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Jump short if zero (ZF = 1).
	fn jz_Label(&mut self, arg0: Label);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn jz_Label_1(&mut self, arg0: Label);

	/// Jump short if zero (ZF = 1).
	fn jz_Label_Hint(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn jz_Label_Hint_1(&mut self, arg0: Label, arg1: Hint);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn jz_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Jump near if 0 (Zero Flag (ZF) is 1).
	fn jz_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint);

	/// Jump short if zero (ZF = 1).
	fn jz_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Jump short if zero (ZF = 1).
	fn jz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint);

	/// Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF).
	fn lahf(&mut self);

	/// r16 = access rights referenced by r16/m16.
	fn lar_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// r16 = access rights referenced by r16/m16.
	fn lar_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// reg = access rights referenced by r32/m16.
	fn lar_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// reg = access rights referenced by r32/m16.
	fn lar_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// reg = access rights referenced by r32/m16.
	fn lar_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory);

	/// reg = access rights referenced by r32/m16.
	fn lar_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit);

	/// Load unaligned data from mem and return double quadword in xmm1.
	fn lddqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Load MXCSR register from m32.
	fn ldmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Store effective address for m in register r16.
	fn lea_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Store effective address for m in register r16.
	fn lea_Register16Bit_Any32BitMemory(&mut self, arg0: Register16Bit, arg1: Any32BitMemory);

	/// Store effective address for m in register r16.
	fn lea_Register16Bit_Any64BitMemory(&mut self, arg0: Register16Bit, arg1: Any64BitMemory);

	/// Store effective address for m in register r32.
	fn lea_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// Store effective address for m in register r32.
	fn lea_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Store effective address for m in register r32.
	fn lea_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory);

	/// Store effective address for m in register r64.
	fn lea_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory);

	/// Store effective address for m in register r64.
	fn lea_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Store effective address for m in register r64.
	fn lea_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Set RSP to RBP, then pop RBP.
	fn leave(&mut self);

	/// Set SP to BP, then pop BP.
	fn leave_Prefix66(&mut self, arg0: Prefix66);

	/// Serializes load operations.
	fn lfence(&mut self);

	/// Load FS:r16 with far pointer from memory.
	fn lfs_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit);

	/// Load FS:r32 with far pointer from memory.
	fn lfs_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit);

	/// Load FS:r64 with far pointer from memory.
	fn lfs_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit);

	/// Load GS:r16 with far pointer from memory.
	fn lgs_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit);

	/// Load GS:r32 with far pointer from memory.
	fn lgs_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit);

	/// Load GS:r64 with far pointer from memory.
	fn lgs_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit);

	/// Asserts LOCK# signal for duration of the accompanying instruction.
	fn lock(&mut self);

	/// For legacy mode, Load word at address DS:(E)SI into AX.
	/// For 64-bit mode load word at address (R)SI into AX.
	fn lods_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// For legacy mode, Load dword at address DS:(E)SI into EAX.
	/// For 64-bit mode load dword at address (R)SI into EAX.
	fn lods_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Load qword at address (R)SI into RAX.
	fn lods_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// For legacy mode, Load byte at address DS:(E)SI into AL.
	/// For 64-bit mode load byte at address (R)SI into AL.
	fn lods_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// For legacy mode, Load byte at address DS:(E)SI into AL.
	/// For 64-bit mode load byte at address (R)SI into AL.
	fn lodsb(&mut self);

	/// For legacy mode, Load dword at address DS:(E)SI into EAX.
	/// For 64-bit mode load dword at address (R)SI into EAX.
	fn lodsd(&mut self);

	/// Load qword at address (R)SI into RAX.
	fn lodsq(&mut self);

	/// For legacy mode, Load word at address DS:(E)SI into AX.
	/// For 64-bit mode load word at address (R)SI into AX.
	fn lodsw(&mut self);

	/// Decrement count; jump short if count != 0.
	fn loop_Label(&mut self, arg0: Label);

	/// Decrement count; jump short if count != 0.
	fn loop_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Decrement count; jump short if count != 0 and  ZF = 1.
	fn loope_Label(&mut self, arg0: Label);

	/// Decrement count; jump short if count != 0 and  ZF = 1.
	fn loope_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Decrement count; jump short if count != 0 and  ZF = 0.
	fn loopne_Label(&mut self, arg0: Label);

	/// Decrement count; jump short if count != 0 and  ZF = 0.
	fn loopne_Relative8Bit(&mut self, arg0: Relative8Bit);

	/// Load: r16 = segment limit, selector r16/m16.
	fn lsl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Load: r16 = segment limit, selector r16/m16.
	fn lsl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Load: r32 = segment limit, selector r32/m16.
	fn lsl_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// Load: r32 = segment limit, selector r32/m16.
	fn lsl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Load: r64 = segment limit, selector r32/m16.
	fn lsl_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory);

	/// Load: r64 = segment limit, selector r32/m16.
	fn lsl_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit);

	/// Load SS:r16 with far pointer from memory.
	fn lss_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit);

	/// Load SS:r32 with far pointer from memory.
	fn lss_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit);

	/// Load SS:r64 with far pointer from memory.
	fn lss_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit);

	/// Count the number of leading zero bits in r/m16, return result in r16.
	fn lzcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Count the number of leading zero bits in r/m16, return result in r16.
	fn lzcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Count the number of leading zero bits in r/m32, return result in r32.
	fn lzcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Count the number of leading zero bits in r/m32, return result in r32.
	fn lzcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Count the number of leading zero bits in r/m64, return result in r64.
	fn lzcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Count the number of leading zero bits in r/m64, return result in r64.
	fn lzcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Selectively write bytes from xmm1 to memory location using the byte mask in xmm2.
	/// The default memory location is specified by DS:DI/EDI/RDI.
	fn maskmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Selectively write bytes from mm1 to memory location using the byte mask in mm2.
	/// The default memory location is specified by DS:DI/EDI/RDI.
	fn maskmovq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
	fn maxpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
	fn maxpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
	fn maxps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
	fn maxps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
	fn maxsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
	fn maxsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
	fn maxss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
	fn maxss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Serializes load and store operations.
	fn mfence(&mut self);

	/// Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
	fn minpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
	fn minpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
	fn minps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
	fn minps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
	fn minsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
	fn minsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
	fn minss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
	fn minss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sets up a linear address range to be monitored by hardware and activates the monitor.
	/// The address range should be a write-back memory caching type.
	/// The address is DS:EAX (DS:RAX in 64-bit mode).
	fn monitor(&mut self);

	/// Move byte at (seg:offset) to AL.
	fn mov_AL_MemoryOffset8Bit(&mut self, arg0: AL, arg1: MemoryOffset8Bit);

	/// Move byte at (offset) to AL.
	fn mov_AL_MemoryOffset8Bit_PrefixRexW(&mut self, arg0: AL, arg1: MemoryOffset8Bit, arg2: PrefixRexW);

	/// Move word at (seg:offset) to AX.
	fn mov_AX_MemoryOffset16Bit(&mut self, arg0: AX, arg1: MemoryOffset16Bit);

	/// Move doubleword at (seg:offset) to EAX.
	fn mov_EAX_MemoryOffset32Bit(&mut self, arg0: EAX, arg1: MemoryOffset32Bit);

	/// Move imm16 to r/m16.
	fn mov_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Move r16 to r/m16.
	fn mov_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Move segment register to r/m16.
	fn mov_Any16BitMemory_Sreg(&mut self, arg0: Any16BitMemory, arg1: Sreg);

	/// Move imm32 to r/m32.
	fn mov_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Move r32 to r/m32.
	fn mov_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Move imm32 sign extended to 64-bits to r/m64.
	fn mov_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Move r64 to r/m64.
	fn mov_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Move zero extended 16-bit segment register to r/m64.
	fn mov_Any64BitMemory_Sreg(&mut self, arg0: Any64BitMemory, arg1: Sreg);

	/// Move imm8 to r/m8.
	fn mov_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Move r8 to r/m8.
	fn mov_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Move r8 to r/m8.
	fn mov_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Move AX to (seg:offset).
	fn mov_MemoryOffset16Bit_AX(&mut self, arg0: MemoryOffset16Bit, arg1: AX);

	/// Move EAX to (seg:offset).
	fn mov_MemoryOffset32Bit_EAX(&mut self, arg0: MemoryOffset32Bit, arg1: EAX);

	/// Move RAX to (offset).
	fn mov_MemoryOffset64Bit_RAX(&mut self, arg0: MemoryOffset64Bit, arg1: RAX);

	/// Move AL to (seg:offset).
	fn mov_MemoryOffset8Bit_AL(&mut self, arg0: MemoryOffset8Bit, arg1: AL);

	/// Move AL to (offset).
	fn mov_MemoryOffset8Bit_AL_PrefixRexW(&mut self, arg0: MemoryOffset8Bit, arg1: AL, arg2: PrefixRexW);

	/// Move imm16 to r16.
	fn mov_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Move imm16 to r/m16.
	fn mov_Register16Bit_Immediate16Bit_1(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Move r/m16 to r16.
	fn mov_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Move r16 to r/m16.
	fn mov_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move r/m16 to r16.
	fn mov_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Move segment register to r/m16.
	fn mov_Register16Bit_Sreg(&mut self, arg0: Register16Bit, arg1: Sreg);

	/// Move imm32 to r32.
	fn mov_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Move imm32 to r/m32.
	fn mov_Register32Bit_Immediate32Bit_1(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Move r/m32 to r32.
	fn mov_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Move r32 to r/m32.
	fn mov_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move r/m32 to r32.
	fn mov_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Move imm32 sign extended to 64-bits to r/m64.
	fn mov_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Move imm64 to r64.
	fn mov_Register64Bit_Immediate64Bit(&mut self, arg0: Register64Bit, arg1: Immediate64Bit);

	/// Move r/m64 to r64.
	fn mov_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move r64 to r/m64.
	fn mov_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move r/m64 to r64.
	fn mov_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Move zero extended 16-bit segment register to r/m64.
	fn mov_Register64Bit_Sreg(&mut self, arg0: Register64Bit, arg1: Sreg);

	/// Move imm8 to r8.
	fn mov_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Move imm8 to r/m8.
	fn mov_Register8Bit_Immediate8Bit_1(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Move r/m8 to r8.
	fn mov_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Move r8 to r/m8.
	fn mov_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Move r/m8 to r8.
	fn mov_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Move r8 to r/m8.
	fn mov_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move r/m8 to r8.
	fn mov_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move quadword at (offset) to RAX.
	fn mov_RAX_MemoryOffset64Bit(&mut self, arg0: RAX, arg1: MemoryOffset64Bit);

	/// Move imm8 to r8.
	fn mov_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Move imm8 to r/m8.
	fn mov_RegisterHigh8BitsOf16Bit_Immediate8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Move r/m8 to r8.
	fn mov_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Move r8 to r/m8.
	fn mov_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Move r/m8 to r8.
	fn mov_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Move r8 to r/m8.
	fn mov_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move r/m8 to r8.
	fn mov_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move r/m16 to segment register.
	fn mov_Sreg_Any16BitMemory(&mut self, arg0: Sreg, arg1: Any16BitMemory);

	/// Move lower 16 bits of r/m64 to segment register.
	fn mov_Sreg_Any64BitMemory(&mut self, arg0: Sreg, arg1: Any64BitMemory);

	/// Move r/m16 to segment register.
	fn mov_Sreg_Register16Bit(&mut self, arg0: Sreg, arg1: Register16Bit);

	/// Move lower 16 bits of r/m64 to segment register.
	fn mov_Sreg_Register64Bit(&mut self, arg0: Sreg, arg1: Register64Bit);

	/// Move packed double-precision floating-point values from xmm1 to xmm2/m128.
	fn movapd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn movapd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn movapd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed double-precision floating-point values from xmm1 to xmm2/m128.
	fn movapd_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm1 to xmm2/m128.
	fn movaps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn movaps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn movaps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm1 to xmm2/m128.
	fn movaps_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Reverse byte order in r16 and move to m16.
	fn movbe_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Reverse byte order in r32 and move to m32.
	fn movbe_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Reverse byte order in r64 and move to m64.
	fn movbe_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Reverse byte order in m16 and move to r16.
	fn movbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Reverse byte order in m32 and move to r32.
	fn movbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Reverse byte order in m64 and move to r64.
	fn movbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Move doubleword from mm to r/m32.
	fn movd_Any32BitMemory_MmRegister(&mut self, arg0: Any32BitMemory, arg1: MmRegister);

	/// Move doubleword from xmm register to r/m32.
	fn movd_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister);

	/// Move doubleword from r/m32 to mm.
	fn movd_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory);

	/// Move doubleword from r/m32 to mm.
	fn movd_MmRegister_Register32Bit(&mut self, arg0: MmRegister, arg1: Register32Bit);

	/// Move doubleword from mm to r/m32.
	fn movd_Register32Bit_MmRegister(&mut self, arg0: Register32Bit, arg1: MmRegister);

	/// Move doubleword from xmm register to r/m32.
	fn movd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Move doubleword from r/m32 to xmm.
	fn movd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Move doubleword from r/m32 to xmm.
	fn movd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit);

	/// Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.
	fn movddup_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.
	fn movddup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move low quadword from xmm to mmx register.
	fn movdq2q_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister);

	/// Move aligned double quadword from xmm1 to xmm2/m128.
	fn movdqa_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move aligned double quadword from xmm2/m128 to xmm1.
	fn movdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move aligned double quadword from xmm2/m128 to xmm1.
	fn movdqa_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned double quadword from xmm1 to xmm2/m128.
	fn movdqa_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned double quadword from xmm1 to xmm2/m128.
	fn movdqu_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move unaligned double quadword from xmm2/m128 to xmm1.
	fn movdqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move unaligned double quadword from xmm2/m128 to xmm1.
	fn movdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned double quadword from xmm1 to xmm2/m128.
	fn movdqu_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.
	fn movhlps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move double-precision floating-point value from high quadword of xmm to m64.
	fn movhpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move double-precision floating-point value from m64 to high quadword of xmm.
	fn movhpd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move two packed single-precision floating-point values from high quadword of xmm to m64.
	fn movhps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move two packed single-precision floating-point values from m64 to high quadword of xmm.
	fn movhps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.
	fn movlhps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move double-precision floating-point nvalue from low quadword of xmm register to m64.
	fn movlpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move double-precision floating-point value from m64 to low quadword of xmm register.
	fn movlpd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move two packed single-precision floating-point values from low quadword of xmm to m64.
	fn movlps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move two packed single-precision floating-point values from m64 to low quadword of xmm.
	fn movlps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Extract 2-bit sign mask from xmm and store in reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn movmskpd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Extract 2-bit sign mask from xmm and store in reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn movmskpd_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Extract 4-bit sign mask from xmm and store in reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn movmskps_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Extract 4-bit sign mask from xmm and store in reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn movmskps_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Move double quadword from xmm to m128 using non-temporal hint.
	fn movntdq_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
	fn movntdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move doubleword from r32 to m32 using non-temporal hint.
	fn movnti_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Move quadword from r64 to m64 using non-temporal hint.
	fn movnti_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.
	fn movntpd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.
	fn movntps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move quadword from mm to m64 using non-temporal hint.
	fn movntq_Any64BitMemory_MmRegister(&mut self, arg0: Any64BitMemory, arg1: MmRegister);

	/// Move quadword from mm to r/m64.
	fn movq_Any64BitMemory_MmRegister(&mut self, arg0: Any64BitMemory, arg1: MmRegister);

	/// Move quadword from mm to mm/m64.
	fn movq_Any64BitMemory_MmRegister_1(&mut self, arg0: Any64BitMemory, arg1: MmRegister);

	/// Move quadword from xmm register to r/m64.
	fn movq_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move quadword from xmm1 to xmm2/mem64.
	fn movq_Any64BitMemory_XMMRegister_1(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move quadword from r/m64 to mm.
	fn movq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Move quadword from mm/m64 to mm.
	fn movq_MmRegister_Any64BitMemory_1(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Move quadword from mm/m64 to mm.
	fn movq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Move quadword from mm to mm/m64.
	fn movq_MmRegister_MmRegister_1(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Move quadword from r/m64 to mm.
	fn movq_MmRegister_Register64Bit(&mut self, arg0: MmRegister, arg1: Register64Bit);

	/// Move quadword from mm to r/m64.
	fn movq_Register64Bit_MmRegister(&mut self, arg0: Register64Bit, arg1: MmRegister);

	/// Move quadword from xmm register to r/m64.
	fn movq_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Move quadword from r/m64 to xmm.
	fn movq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move quadword from xmm2/mem64 to xmm1.
	fn movq_XMMRegister_Any64BitMemory_1(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move quadword from r/m64 to xmm.
	fn movq_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit);

	/// Move quadword from xmm2/mem64 to xmm1.
	fn movq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move quadword from xmm1 to xmm2/mem64.
	fn movq_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move quadword from mmx to low quadword of xmm.
	fn movq2dq_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister);

	/// For legacy mode, move word from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move word at address (R|E)SI to (R|E)DI.
	fn movs_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory);

	/// For legacy mode, move dword from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
	fn movs_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory);

	/// Move qword from address (R|E)SI to (R|E)DI.
	fn movs_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory);

	/// For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
	fn movs_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move byte from address (R|E)SI to (R|E)DI.
	fn movsb(&mut self);

	/// For legacy mode, move dword from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
	fn movsd(&mut self);

	/// Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.
	fn movsd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
	fn movsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
	fn movsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.
	fn movsd_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.
	fn movshdup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.
	fn movshdup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.
	fn movsldup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.
	fn movsldup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move qword from address (R|E)SI to (R|E)DI.
	fn movsq(&mut self);

	/// Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.
	fn movss_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister);

	/// Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
	fn movss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
	fn movss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.
	fn movss_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// For legacy mode, move word from address DS:(E)SI to ES:(E)DI.
	/// For 64-bit mode move word at address (R|E)SI to (R|E)DI.
	fn movsw(&mut self);

	/// Move byte to word with sign-extension.
	fn movsx_Register16Bit_Any8BitMemory(&mut self, arg0: Register16Bit, arg1: Any8BitMemory);

	/// Move byte to word with sign-extension.
	fn movsx_Register16Bit_Register8Bit(&mut self, arg0: Register16Bit, arg1: Register8Bit);

	/// Move byte to word with sign-extension.
	fn movsx_Register16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move word to doubleword, with sign-extension.
	fn movsx_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// Move byte to doubleword with sign-extension.
	fn movsx_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory);

	/// Move word to doubleword, with sign-extension.
	fn movsx_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit);

	/// Move byte to doubleword with sign-extension.
	fn movsx_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit);

	/// Move byte to doubleword with sign-extension.
	fn movsx_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move word to quadword with sign-extension.
	fn movsx_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory);

	/// Move byte to quadword with sign-extension.
	fn movsx_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory);

	/// Move word to quadword with sign-extension.
	fn movsx_Register64Bit_Register16Bit(&mut self, arg0: Register64Bit, arg1: Register16Bit);

	/// Move byte to quadword with sign-extension.
	fn movsx_Register64Bit_Register8Bit(&mut self, arg0: Register64Bit, arg1: Register8Bit);

	/// Move doubleword to quadword with sign-extension.
	fn movsxd_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Move doubleword to quadword with sign-extension.
	fn movsxd_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit);

	/// Move packed double-precision floating-point values from xmm1 to xmm2/m128.
	fn movupd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn movupd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move packed double-precision floating-point values from xmm2/m128 to xmm1.
	fn movupd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed double-precision floating-point values from xmm1 to xmm2/m128.
	fn movupd_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm1 to xmm2/m128.
	fn movups_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn movups_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move packed single-precision floating-point values from xmm2/m128 to xmm1.
	fn movups_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move packed single-precision floating-point values from xmm1 to xmm2/m128.
	fn movups_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move byte to word with zero-extension.
	fn movzx_Register16Bit_Any8BitMemory(&mut self, arg0: Register16Bit, arg1: Any8BitMemory);

	/// Move byte to word with zero-extension.
	fn movzx_Register16Bit_Register8Bit(&mut self, arg0: Register16Bit, arg1: Register8Bit);

	/// Move byte to word with zero-extension.
	fn movzx_Register16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move word to doubleword, zero-extension.
	fn movzx_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory);

	/// Move byte to doubleword, zero-extension.
	fn movzx_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory);

	/// Move word to doubleword, zero-extension.
	fn movzx_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit);

	/// Move byte to doubleword, zero-extension.
	fn movzx_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit);

	/// Move byte to doubleword, zero-extension.
	fn movzx_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Move word to quadword, zero-extension.
	fn movzx_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory);

	/// Move byte to quadword, zero-extension.
	fn movzx_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory);

	/// Move word to quadword, zero-extension.
	fn movzx_Register64Bit_Register16Bit(&mut self, arg0: Register64Bit, arg1: Register16Bit);

	/// Move byte to quadword, zero-extension.
	fn movzx_Register64Bit_Register8Bit(&mut self, arg0: Register64Bit, arg1: Register8Bit);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1.
	/// Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
	fn mpsadbw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1.
	/// Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
	fn mpsadbw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Unsigned multiply (DX:AX = AX * r/m16).
	fn mul_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Unsigned multiply (`EDX:EAX` = EAX * r/m32).
	fn mul_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Unsigned multiply (`RDX:RAX` = RAX * r/m64.
	fn mul_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Unsigned multiply (AX = AL * r/m8).
	fn mul_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Unsigned multiply (DX:AX = AX * r/m16).
	fn mul_Register16Bit(&mut self, arg0: Register16Bit);

	/// Unsigned multiply (`EDX:EAX` = EAX * r/m32).
	fn mul_Register32Bit(&mut self, arg0: Register32Bit);

	/// Unsigned multiply (`RDX:RAX` = RAX * r/m64.
	fn mul_Register64Bit(&mut self, arg0: Register64Bit);

	/// Unsigned multiply (AX = AL * r/m8).
	fn mul_Register8Bit(&mut self, arg0: Register8Bit);

	/// Unsigned multiply (AX = AL * r/m8).
	fn mul_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
	fn mulpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
	fn mulpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
	fn mulps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
	fn mulps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
	fn mulsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
	fn mulsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
	fn mulss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
	fn mulss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unsigned multiply of r/m32 with EDX without affecting arithmetic flags.
	fn mulx_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory);

	/// Unsigned multiply of r/m32 with EDX without affecting arithmetic flags.
	fn mulx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Unsigned multiply of r/m64 with RDX without affecting arithmetic flags.
	fn mulx_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory);

	/// Unsigned multiply of r/m64 with RDX without affecting arithmetic flags.
	fn mulx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.
	fn mwait(&mut self);

	/// Two's complement negate r/m16.
	fn neg_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Two's complement negate r/m32.
	fn neg_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Two's complement negate r/m64.
	fn neg_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Two's complement negate r/m8.
	fn neg_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Two's complement negate r/m16.
	fn neg_Register16Bit(&mut self, arg0: Register16Bit);

	/// Two's complement negate r/m32.
	fn neg_Register32Bit(&mut self, arg0: Register32Bit);

	/// Two's complement negate r/m64.
	fn neg_Register64Bit(&mut self, arg0: Register64Bit);

	/// Two's complement negate r/m8.
	fn neg_Register8Bit(&mut self, arg0: Register8Bit);

	/// Two's complement negate r/m8.
	fn neg_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// One byte no-operation instruction.
	fn nop(&mut self);

	/// Multi-byte no-operation instruction.
	fn nop_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Multi-byte no-operation instruction.
	fn nop_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Multi-byte no-operation instruction.
	fn nop_Register16Bit(&mut self, arg0: Register16Bit);

	/// Multi-byte no-operation instruction.
	fn nop_Register32Bit(&mut self, arg0: Register32Bit);

	/// Reverse each bit of r/m16.
	fn not_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Reverse each bit of r/m32.
	fn not_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Reverse each bit of r/m64.
	fn not_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Reverse each bit of r/m8.
	fn not_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Reverse each bit of r/m16.
	fn not_Register16Bit(&mut self, arg0: Register16Bit);

	/// Reverse each bit of r/m32.
	fn not_Register32Bit(&mut self, arg0: Register32Bit);

	/// Reverse each bit of r/m64.
	fn not_Register64Bit(&mut self, arg0: Register64Bit);

	/// Reverse each bit of r/m8.
	fn not_Register8Bit(&mut self, arg0: Register8Bit);

	/// Reverse each bit of r/m8.
	fn not_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// AL OR imm8.
	fn or_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// AX OR imm16.
	fn or_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// EAX OR imm32.
	fn or_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// r/m16 OR imm16.
	fn or_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// r/m16 OR imm8 (sign-extended).
	fn or_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// r/m16 OR r16.
	fn or_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// r/m32 OR imm32.
	fn or_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// r/m32 OR imm8 (sign-extended).
	fn or_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// r/m32 OR r32.
	fn or_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// r/m64 OR imm32 (sign-extended).
	fn or_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// r/m64 OR imm8 (sign-extended).
	fn or_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// r/m64 OR r64.
	fn or_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// r/m8 OR imm8.
	fn or_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// r/m8 OR r8.
	fn or_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// r/m8 OR r8.
	fn or_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// r/m16 OR imm16.
	fn or_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// r/m16 OR imm8 (sign-extended).
	fn or_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// r16 OR r/m16.
	fn or_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// r/m16 OR r16.
	fn or_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r16 OR r/m16.
	fn or__Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r/m32 OR imm32.
	fn or_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// r/m32 OR imm8 (sign-extended).
	fn or_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// r32 OR r/m32.
	fn or_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// r/m32 OR r32.
	fn or_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r32 OR r/m32.
	fn or__Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r/m64 OR imm32 (sign-extended).
	fn or_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// r/m64 OR imm8 (sign-extended).
	fn or_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// r64 OR r/m64.
	fn or_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// r/m64 OR r64.
	fn or_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r64 OR r/m64.
	fn or__Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r/m8 OR imm8.
	fn or_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// r8 OR r/m8.
	fn or_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// r/m8 OR r8.
	fn or_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r8 OR r/m8.
	fn or__Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r/m8 OR r8.
	fn or_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 OR r/m8.
	fn or__Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// RAX OR imm32 (sign-extended).
	fn or_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// r/m8 OR imm8.
	fn or_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// r8 OR r/m8.
	fn or_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// r/m8 OR r8.
	fn or_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r8 OR r/m8.
	fn or__RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r/m8 OR r8.
	fn or_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 OR r/m8.
	fn or__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Bitwise OR of xmm2/m128 and xmm1.
	fn orpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise OR of xmm2/m128 and xmm1.
	fn orpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Bitwise OR of xmm1 and xmm2/m128.
	fn orps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise OR of xmm1 and xmm2/m128.
	fn orps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Output byte in AL to I/O port address in DX.
	fn out_DX_AL(&mut self, arg0: DX, arg1: AL);

	/// Output word in AX to I/O port address in DX.
	fn out_DX_AX(&mut self, arg0: DX, arg1: AX);

	/// Output doubleword in EAX to I/O port address in DX.
	fn out_DX_EAX(&mut self, arg0: DX, arg1: EAX);

	/// Output byte in AL to I/O port address imm8.
	fn out_Immediate8Bit_AL(&mut self, arg0: Immediate8Bit, arg1: AL);

	/// Output word in AX to I/O port address imm8.
	fn out_Immediate8Bit_AX(&mut self, arg0: Immediate8Bit, arg1: AX);

	/// Output doubleword in EAX to I/O port address imm8.
	fn out_Immediate8Bit_EAX(&mut self, arg0: Immediate8Bit, arg1: EAX);

	/// Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outs_DX_Any16BitMemory(&mut self, arg0: DX, arg1: Any16BitMemory);

	/// Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outs_DX_Any32BitMemory(&mut self, arg0: DX, arg1: Any32BitMemory);

	/// Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outs_DX_Any8BitMemory(&mut self, arg0: DX, arg1: Any8BitMemory);

	/// Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outsb(&mut self);

	/// Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outsd(&mut self);

	/// Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX.
	fn outsw(&mut self);

	/// Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.
	fn pabsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn pabsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.
	fn packssdw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.
	fn packssdw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
	fn packssdw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
	fn packssdw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.
	fn packsswb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.
	fn packsswb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
	fn packsswb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
	fn packsswb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
	fn packusdw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
	fn packusdw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.
	fn packuswb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.
	fn packuswb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
	fn packuswb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
	fn packuswb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed byte integers from mm/m64 and mm.
	fn paddb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed byte integers from mm/m64 and mm.
	fn paddb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed byte integers from xmm2/m128 and xmm1.
	fn paddb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed byte integers from xmm2/m128 and xmm1.
	fn paddb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed doubleword integers from mm/m64 and mm.
	fn paddd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed doubleword integers from mm/m64 and mm.
	fn paddd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed doubleword integers from xmm2/m128 and xmm1.
	fn paddd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed doubleword integers from xmm2/m128 and xmm1.
	fn paddd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add quadword integer mm2/m64 to mm1.
	fn paddq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add quadword integer mm2/m64 to mm1.
	fn paddq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed quadword integers xmm2/m128 to xmm1.
	fn paddq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed quadword integers xmm2/m128 to xmm1.
	fn paddq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed signed byte integers from mm/m64 and mm and saturate the results.
	fn paddsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed signed byte integers from mm/m64 and mm and saturate the results.
	fn paddsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
	fn paddsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
	fn paddsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed signed word integers from mm/m64 and mm and saturate the results.
	fn paddsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed signed word integers from mm/m64 and mm and saturate the results.
	fn paddsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
	fn paddsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
	fn paddsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed unsigned byte integers from mm/m64 and mm and saturate the results.
	fn paddusb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed unsigned byte integers from mm/m64 and mm and saturate the results.
	fn paddusb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
	fn paddusb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
	fn paddusb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed unsigned word integers from mm/m64 and mm and saturate the results.
	fn paddusw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed unsigned word integers from mm/m64 and mm and saturate the results.
	fn paddusw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
	fn paddusw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
	fn paddusw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed word integers from mm/m64 and mm.
	fn paddw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add packed word integers from mm/m64 and mm.
	fn paddw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add packed word integers from xmm2/m128 and xmm1.
	fn paddw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add packed word integers from xmm2/m128 and xmm1.
	fn paddw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.
	fn palignr_MmRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.
	fn palignr_MmRegister_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: MmRegister, arg2: Immediate8Bit);

	/// Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1.
	fn palignr_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1.
	fn palignr_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Bitwise AND mm/m64 and mm.
	fn pand_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Bitwise AND mm/m64 and mm.
	fn pand_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Bitwise AND of xmm2/m128 and xmm1.
	fn pand_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise AND of xmm2/m128 and xmm1.
	fn pand_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Bitwise AND NOT of mm/m64 and mm.
	fn pandn_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Bitwise AND NOT of mm/m64 and mm.
	fn pandn_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Bitwise AND NOT of xmm2/m128 and xmm1.
	fn pandn_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise AND NOT of xmm2/m128 and xmm1.
	fn pandn_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Gives hint to processor that improves performance of spin-wait loops.
	fn pause(&mut self);

	/// Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.
	fn pavgb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.
	fn pavgb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
	fn pavgb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
	fn pavgb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Average packed unsigned word integers from mm2/m64 and mm1 with rounding.
	fn pavgw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Average packed unsigned word integers from mm2/m64 and mm1 with rounding.
	fn pavgw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
	fn pavgw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
	fn pavgw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
	fn pblendvb_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0);

	/// Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
	fn pblendvb_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0);

	/// Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn pblendw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
	fn pblendw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1.
	/// The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.
	fn pclmulqdq_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1.
	/// The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.
	fn pclmulqdq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Compare packed bytes in mm/m64 and mm for equality.
	fn pcmpeqb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed bytes in mm/m64 and mm for equality.
	fn pcmpeqb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed bytes in xmm2/m128 and xmm1 for equality.
	fn pcmpeqb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed bytes in xmm2/m128 and xmm1 for equality.
	fn pcmpeqb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed doublewords in mm/m64 and mm for equality.
	fn pcmpeqd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed doublewords in mm/m64 and mm for equality.
	fn pcmpeqd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed doublewords in xmm2/m128 and xmm1 for equality.
	fn pcmpeqd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed doublewords in xmm2/m128 and xmm1 for equality.
	fn pcmpeqd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed qwords in xmm2/m128 and xmm1 for equality.
	fn pcmpeqq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed qwords in xmm2/m128 and xmm1 for equality.
	fn pcmpeqq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed words in mm/m64 and mm for equality.
	fn pcmpeqw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed words in mm/m64 and mm for equality.
	fn pcmpeqw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed words in xmm2/m128 and xmm1 for equality.
	fn pcmpeqw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed words in xmm2/m128 and xmm1 for equality.
	fn pcmpeqw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
	fn pcmpestri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
	fn pcmpestri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.
	fn pcmpestrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.
	fn pcmpestrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Compare packed signed byte integers in mm and mm/m64 for greater than.
	fn pcmpgtb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed signed byte integers in mm and mm/m64 for greater than.
	fn pcmpgtb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed doubleword integers in mm and mm/m64 for greater than.
	fn pcmpgtd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed signed doubleword integers in mm and mm/m64 for greater than.
	fn pcmpgtd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
	fn pcmpgtq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
	fn pcmpgtq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed word integers in mm and mm/m64 for greater than.
	fn pcmpgtw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare packed signed word integers in mm and mm/m64 for greater than.
	fn pcmpgtw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
	fn pcmpgtw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
	fn pcmpistri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
	fn pcmpistri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
	fn pcmpistrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
	fn pcmpistrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a.
	fn pdep_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory);

	/// Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a.
	fn pdep_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a.
	fn pdep_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory);

	/// Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a.
	fn pdep_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Parallel extract of bits from r32b using mask in r/m32, result is written to r32a.
	fn pext_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory);

	/// Parallel extract of bits from r32b using mask in r/m32, result is written to r32a.
	fn pext_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Parallel extract of bits from r64b using mask in r/m64, result is written to r64a.
	fn pext_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory);

	/// Parallel extract of bits from r64b using mask in r/m64, result is written to r64a.
	fn pext_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8.
	/// The upper bits of r32 or r64 are zeroed.
	fn pextrb_Any8BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8.
	/// The upper bits of r32 or r64 are zeroed.
	fn pextrb_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8.
	/// The upper bits of r32 or r64 are zeroed.
	fn pextrb_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
	fn pextrd_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
	fn pextrd_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
	fn pextrq_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
	fn pextrq_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16.
	/// Zero-extend the result in the destination, r32 or r64.
	fn pextrw_Any16BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from mm and move it to reg, bits 15-0.
	/// The upper bits of r32 or r64 is zeroed.
	fn pextrw_Register32Bit_MmRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: MmRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm and move it to reg, bits 15-0.
	/// The upper bits of r32 or r64 is zeroed.
	fn pextrw_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16.
	/// Zero-extend the result in the destination, r32 or r64.
	fn pextrw_Register32Bit_XMMRegister_Immediate8Bit_1(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg3: Immediate8Bit);

	/// Extract the word specified by imm8 from mm and move it to reg, bits 15-0.
	/// The upper bits of r32 or r64 is zeroed.
	fn pextrw_Register64Bit_MmRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: MmRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm and move it to reg, bits 15-0.
	/// The upper bits of r32 or r64 is zeroed.
	fn pextrw_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16.
	/// Zero-extend the result in the destination, r32 or r64.
	fn pextrw_Register64Bit_XMMRegister_Immediate8Bit_1(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg3: Immediate8Bit);

	/// Add 32-bit integers horizontally, pack to MM1.
	fn phaddd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add 32-bit integers horizontally, pack to MM1.
	fn phaddd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add 32-bit integers horizontally, pack to XMM1.
	fn phaddd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add 32-bit integers horizontally, pack to XMM1.
	fn phaddd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add 16-bit signed integers horizontally, pack saturated integers to MM1.
	fn phaddsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add 16-bit signed integers horizontally, pack saturated integers to MM1.
	fn phaddsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add 16-bit signed integers horizontally, pack saturated integers to XMM1.
	fn phaddsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add 16-bit signed integers horizontally, pack saturated integers to XMM1.
	fn phaddsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add 16-bit integers horizontally, pack to MM1.
	fn phaddw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Add 16-bit integers horizontally, pack to MM1.
	fn phaddw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Add 16-bit integers horizontally, pack to XMM1.
	fn phaddw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Add 16-bit integers horizontally, pack to XMM1.
	fn phaddw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
	fn phminposuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
	fn phminposuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract 32-bit signed integers horizontally, pack to MM1.
	fn phsubd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract 32-bit signed integers horizontally, pack to MM1.
	fn phsubd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract 32-bit signed integers horizontally, pack to XMM1.
	fn phsubd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract 32-bit signed integers horizontally, pack to XMM1.
	fn phsubd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.
	fn phsubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.
	fn phsubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1.
	fn phsubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1.
	fn phsubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract 16-bit signed integers horizontally, pack to MM1.
	fn phsubw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract 16-bit signed integers horizontally, pack to MM1.
	fn phsubw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract 16-bit signed integers horizontally, pack to XMM1.
	fn phsubw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract 16-bit signed integers horizontally, pack to XMM1.
	fn phsubw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
	fn pinsrb_XMMRegister_Any8BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any8BitMemory, arg2: Immediate8Bit);

	/// Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
	fn pinsrb_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
	fn pinsrd_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
	fn pinsrd_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Insert the low word from r32 or from m16 into mm at the word position specified by imm8.
	fn pinsrw_MmRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any16BitMemory, arg2: Immediate8Bit);

	/// Insert the low word from r32 or from m16 into mm at the word position specified by imm8.
	fn pinsrw_MmRegister_Register32Bit_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
	fn pinsrw_XMMRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any16BitMemory, arg2: Immediate8Bit);

	/// Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
	fn pinsrw_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.
	fn pmaddubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.
	fn pmaddubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.
	fn pmaddubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.
	fn pmaddubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.
	fn pmaddwd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.
	fn pmaddwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
	fn pmaddwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
	fn pmaddwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare signed word integers in mm2/m64 and mm1 and return maximum values.
	fn pmaxsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare signed word integers in mm2/m64 and mm1 and return maximum values.
	fn pmaxsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
	fn pmaxsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
	fn pmaxsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.
	fn pmaxub_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.
	fn pmaxub_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
	fn pmaxub_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
	fn pmaxub_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxud_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxud_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
	fn pmaxuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare signed word integers in mm2/m64 and mm1 and return minimum values.
	fn pminsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare signed word integers in mm2/m64 and mm1 and return minimum values.
	fn pminsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
	fn pminsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
	fn pminsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.
	fn pminub_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.
	fn pminub_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
	fn pminub_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
	fn pminub_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminud_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminud_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
	fn pminuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move a byte mask of mm to reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn pmovmskb_Register32Bit_MmRegister(&mut self, arg0: Register32Bit, arg1: MmRegister);

	/// Move a byte mask of xmm to reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn pmovmskb_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Move a byte mask of mm to reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn pmovmskb_Register64Bit_MmRegister(&mut self, arg0: Register64Bit, arg1: MmRegister);

	/// Move a byte mask of xmm to reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn pmovmskb_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
	fn pmovsxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
	fn pmovsxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory);

	/// Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
	fn pmovsxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
	fn pmovsxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
	fn pmovsxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
	fn pmovsxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
	fn pmovsxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn pmovzxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn pmovzxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn pmovzxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory);

	/// Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn pmovzxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn pmovzxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn pmovzxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn pmovzxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn pmovzxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn pmovzxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn pmovzxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn pmovzxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn pmovzxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
	fn pmuldq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
	fn pmuldq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.
	fn pmulhrsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.
	fn pmulhrsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.
	fn pmulhrsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.
	fn pmulhrsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
	fn pmulhuw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
	fn pmulhuw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
	fn pmulhuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
	fn pmulhuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
	fn pmulhw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.
	fn pmulhw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
	fn pmulhw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
	fn pmulhw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
	fn pmulld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
	fn pmulld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.
	fn pmullw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.
	fn pmullw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
	fn pmullw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
	fn pmullw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.
	fn pmuludq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.
	fn pmuludq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
	fn pmuludq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
	fn pmuludq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Pop top of stack into FS; increment stack pointer by 64 bits.
	fn pop_FS(&mut self, arg0: FS);

	/// Pop top of stack into FS; increment stack pointer by 16 bits.
	fn pop_FS_Prefix66(&mut self, arg0: FS, arg1: Prefix66);

	/// Pop top of stack into GS; increment stack pointer by 64 bits.
	fn pop_GS(&mut self, arg0: GS);

	/// Pop top of stack into GS; increment stack pointer by 16 bits.
	fn pop_GS_Prefix66(&mut self, arg0: GS, arg1: Prefix66);

	/// Pop top of stack into m16; increment stack pointer.
	fn pop_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Pop top of stack into m64; increment stack pointer.
	/// Cannot encode 32-bit operand size.
	fn pop_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Pop top of stack into m16; increment stack pointer.
	fn pop_Register16Bit(&mut self, arg0: Register16Bit);

	/// Pop top of stack into r16; increment stack pointer.
	fn pop_Register16Bit_1(&mut self, arg0: Register16Bit);

	/// Pop top of stack into m64; increment stack pointer.
	/// Cannot encode 32-bit operand size.
	fn pop_Register64Bit(&mut self, arg0: Register64Bit);

	/// Pop top of stack into r64; increment stack pointer.
	/// Cannot encode 32-bit operand size.
	fn pop_Register64Bit_1(&mut self, arg0: Register64Bit);

	/// POPCNT on r/m16.
	fn popcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// POPCNT on r/m16.
	fn popcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// POPCNT on r/m32.
	fn popcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// POPCNT on r/m32.
	fn popcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// POPCNT on r/m64.
	fn popcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// POPCNT on r/m64.
	fn popcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Pop top of stack into lower 16 bits of EFLAGS.
	fn popf(&mut self);

	/// Pop top of stack and zero-extend into RFLAGS.
	fn popfq(&mut self);

	/// Bitwise OR of mm/m64 and mm.
	fn por_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Bitwise OR of mm/m64 and mm.
	fn por_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Bitwise OR of xmm2/m128 and xmm1.
	fn por_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise OR of xmm2/m128 and xmm1.
	fn por_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move data from m8 closer to the processor using NTA hint.
	fn prefetchnta_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Move data from m8 closer to the processor using T0 hint.
	fn prefetcht0_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Move data from m8 closer to the processor using T1 hint.
	fn prefetcht1_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Move data from m8 closer to the processor using T2 hint.
	fn prefetcht2_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.
	fn psadbw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.
	fn psadbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
	fn psadbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
	fn psadbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shuffle bytes in mm1 according to contents of mm2/m64.
	fn pshufb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shuffle bytes in mm1 according to contents of mm2/m64.
	fn pshufb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shuffle bytes in xmm1 according to contents of xmm2/m128.
	fn pshufb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shuffle bytes in xmm1 according to contents of xmm2/m128.
	fn pshufb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshufd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshufd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshufhw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshufhw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshuflw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn pshuflw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.
	fn pshufw_MmRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.
	fn pshufw_MmRegister_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: MmRegister, arg2: Immediate8Bit);

	/// Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64.
	fn psignb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64.
	fn psignb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.
	fn psignd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.
	fn psignd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.
	fn psignw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.
	fn psignw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.
	fn psignw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift doublewords in mm left by imm8 while shifting in 0s.
	fn pslld_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift doublewords in mm left by mm/m64 while shifting in 0s.
	fn pslld_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift doublewords in mm left by mm/m64 while shifting in 0s.
	fn pslld_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift doublewords in xmm1 left by imm8 while shifting in 0s.
	fn pslld_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
	fn pslld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
	fn pslld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift xmm1 left by imm8 bytes while shifting in 0s.
	fn pslldq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift quadword in mm left by imm8 while shifting in 0s.
	fn psllq_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift quadword in mm left by mm/m64 while shifting in 0s.
	fn psllq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift quadword in mm left by mm/m64 while shifting in 0s.
	fn psllq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift quadwords in xmm1 left by imm8 while shifting in 0s.
	fn psllq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
	fn psllq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
	fn psllq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift words in mm left by imm8 while shifting in 0s.
	fn psllw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift words in mm left mm/m64 while shifting in 0s.
	fn psllw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift words in mm left mm/m64 while shifting in 0s.
	fn psllw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift words in xmm1 left by imm8 while shifting in 0s.
	fn psllw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
	fn psllw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
	fn psllw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift doublewords in mm right by imm8 while shifting in sign bits.
	fn psrad_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift doublewords in mm right by mm/m64 while shifting in sign bits.
	fn psrad_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift doublewords in mm right by mm/m64 while shifting in sign bits.
	fn psrad_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift doublewords in xmm1 right by imm8 while shifting in sign bits.
	fn psrad_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
	fn psrad_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
	fn psrad_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift words in mm right by imm8 while shifting in sign bits.
	fn psraw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift words in mm right by mm/m64 while shifting in sign bits.
	fn psraw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift words in mm right by mm/m64 while shifting in sign bits.
	fn psraw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift words in xmm1 right by imm8 while shifting in sign bits.
	fn psraw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
	fn psraw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
	fn psraw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift doublewords in mm right by imm8 while shifting in 0s.
	fn psrld_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrld_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrld_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift doublewords in xmm1 right by imm8 while shifting in 0s.
	fn psrld_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
	fn psrld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
	fn psrld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift xmm1 right by imm8 while shifting in 0s.
	fn psrldq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift mm right by imm8 while shifting in 0s.
	fn psrlq_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrlq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrlq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift quadwords in xmm1 right by imm8 while shifting in 0s.
	fn psrlq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
	fn psrlq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
	fn psrlq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Shift words in mm right by imm8 while shifting in 0s.
	fn psrlw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit);

	/// Shift words in mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrlw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Shift words in mm right by amount specified in mm/m64 while shifting in 0s.
	fn psrlw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Shift words in xmm1 right by imm8 while shifting in 0s.
	fn psrlw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit);

	/// Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
	fn psrlw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
	fn psrlw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract packed byte integers in mm/m64 from packed byte integers in mm.
	fn psubb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract packed byte integers in mm/m64 from packed byte integers in mm.
	fn psubb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
	fn psubb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
	fn psubb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.
	fn psubd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.
	fn psubd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
	fn psubd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
	fn psubd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract quadword integer in mm1 from mm2 /m64.
	fn psubq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract quadword integer in mm1 from mm2 /m64.
	fn psubq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed quadword integers in xmm1 from xmm2 /m128.
	fn psubq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed quadword integers in xmm1 from xmm2 /m128.
	fn psubq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.
	fn psubsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.
	fn psubsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
	fn psubsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
	fn psubsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.
	fn psubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.
	fn psubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
	fn psubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
	fn psubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.
	fn psubusb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.
	fn psubusb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
	fn psubusb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
	fn psubusb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.
	fn psubusw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.
	fn psubusw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
	fn psubusw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
	fn psubusw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract packed word integers in mm/m64 from packed word integers in mm.
	fn psubw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Subtract packed word integers in mm/m64 from packed word integers in mm.
	fn psubw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
	fn psubw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
	fn psubw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Set ZF if xmm2/m128 AND xmm1 result is all 0s.
	/// Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
	fn ptest_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Set ZF if xmm2/m128 AND xmm1 result is all 0s.
	/// Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
	fn ptest_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpack and interleave high-order bytes from mm and mm/m64 into mm.
	fn punpckhbw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Unpack and interleave high-order bytes from mm and mm/m64 into mm.
	fn punpckhbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
	fn punpckhbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
	fn punpckhbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpack and interleave high-order doublewords from mm and mm/m64 into mm.
	fn punpckhdq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Unpack and interleave high-order doublewords from mm and mm/m64 into mm.
	fn punpckhdq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
	fn punpckhdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
	fn punpckhdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
	fn punpckhqdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
	fn punpckhqdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpack and interleave high-order words from mm and mm/m64 into mm.
	fn punpckhwd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Unpack and interleave high-order words from mm and mm/m64 into mm.
	fn punpckhwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
	fn punpckhwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
	fn punpckhwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Interleave low-order bytes from mm and mm/m32 into mm.
	fn punpcklbw_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory);

	/// Interleave low-order bytes from mm and mm/m32 into mm.
	fn punpcklbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
	fn punpcklbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
	fn punpcklbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Interleave low-order doublewords from mm and mm/m32 into mm.
	fn punpckldq_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory);

	/// Interleave low-order doublewords from mm and mm/m32 into mm.
	fn punpckldq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
	fn punpckldq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
	fn punpckldq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
	fn punpcklqdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
	fn punpcklqdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Interleave low-order words from mm and mm/m32 into mm.
	fn punpcklwd_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory);

	/// Interleave low-order words from mm and mm/m32 into mm.
	fn punpcklwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
	fn punpcklwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
	fn punpcklwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Push FS.
	fn push_FS(&mut self, arg0: FS);

	/// Push GS.
	fn push_GS(&mut self, arg0: GS);

	/// Push r/m16.
	fn push_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Push r/m64.
	fn push_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Push r/m16.
	fn push_Register16Bit(&mut self, arg0: Register16Bit);

	/// Push r16.
	fn push_Register16Bit_1(&mut self, arg0: Register16Bit);

	/// Push r/m64.
	fn push_Register64Bit(&mut self, arg0: Register64Bit);

	/// Push r64.
	fn push_Register64Bit_1(&mut self, arg0: Register64Bit);

	/// Push lower 16 bits of EFLAGS.
	fn pushf(&mut self);

	/// Push RFLAGS.
	fn pushfq(&mut self);

	/// Push imm16 (sign-extended to 64-bits).
	fn pushq_Immediate16Bit(&mut self, arg0: Immediate16Bit);

	/// Push imm32 (sign-extended to 64-bits).
	fn pushq_Immediate32Bit(&mut self, arg0: Immediate32Bit);

	/// Push imm8 (sign-extended to 64-bits).
	fn pushq_Immediate8Bit(&mut self, arg0: Immediate8Bit);

	/// Push imm16 (sign-extended to 16-bits).
	fn pushw_Immediate16Bit(&mut self, arg0: Immediate16Bit);

	/// Push imm8 (sign-extended to 16-bits).
	fn pushw_Immediate8Bit(&mut self, arg0: Immediate8Bit);

	/// Bitwise XOR of mm/m64 and mm.
	fn pxor_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory);

	/// Bitwise XOR of mm/m64 and mm.
	fn pxor_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister);

	/// Bitwise XOR of xmm2/m128 and xmm1.
	fn pxor_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise XOR of xmm2/m128 and xmm1.
	fn pxor_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Rotate 17 bits (CF, r/m16) left CL times.
	fn rcl_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Rotate 17 bits (CF, r/m16) left imm8 times.
	fn rcl_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Rotate 17 bits (CF, r/m16) left once.
	fn rcl_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Rotate 33 bits (CF, r/m32) left CL times.
	fn rcl_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Rotate 33 bits (CF, r/m32) left imm8 times.
	fn rcl_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Rotate 33 bits (CF, r/m32) left once.
	fn rcl_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Rotate 65 bits (CF, r/m64) left CL times.
	/// Uses a 6 bit count.
	fn rcl_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Rotate 65 bits (CF, r/m64) left imm8 times.
	/// Uses a 6 bit count.
	fn rcl_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Rotate 65 bits (CF, r/m64) left once.
	/// Uses a 6 bit count.
	fn rcl_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Rotate 9 bits (CF, r/m8) left CL times.
	fn rcl_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) left imm8 times.
	fn rcl_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) left once.
	fn rcl_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Rotate 17 bits (CF, r/m16) left CL times.
	fn rcl_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Rotate 17 bits (CF, r/m16) left imm8 times.
	fn rcl_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Rotate 17 bits (CF, r/m16) left once.
	fn rcl_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Rotate 33 bits (CF, r/m32) left CL times.
	fn rcl_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Rotate 33 bits (CF, r/m32) left imm8 times.
	fn rcl_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Rotate 33 bits (CF, r/m32) left once.
	fn rcl_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Rotate 65 bits (CF, r/m64) left CL times.
	/// Uses a 6 bit count.
	fn rcl_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Rotate 65 bits (CF, r/m64) left imm8 times.
	/// Uses a 6 bit count.
	fn rcl_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Rotate 65 bits (CF, r/m64) left once.
	/// Uses a 6 bit count.
	fn rcl_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Rotate 9 bits (CF, r/m8) left CL times.
	fn rcl_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) left imm8 times.
	fn rcl_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) left once.
	fn rcl_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Rotate 9 bits (CF, r/m8) left CL times.
	fn rcl_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) left imm8 times.
	fn rcl_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) left once.
	fn rcl_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn rcpps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn rcpps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
	fn rcpss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
	fn rcpss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Rotate 17 bits (CF, r/m16) right CL times.
	fn rcr_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Rotate 17 bits (CF, r/m16) right imm8 times.
	fn rcr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Rotate 17 bits (CF, r/m16) right once.
	fn rcr_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Rotate 33 bits (CF, r/m32) right CL times.
	fn rcr_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Rotate 33 bits (CF, r/m32) right imm8 times.
	fn rcr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Rotate 33 bits (CF, r/m32) right once.
	/// Uses a 6 bit count.
	fn rcr_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Rotate 65 bits (CF, r/m64) right CL times.
	/// Uses a 6 bit count.
	fn rcr_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Rotate 65 bits (CF, r/m64) right imm8 times.
	/// Uses a 6 bit count.
	fn rcr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Rotate 65 bits (CF, r/m64) right once.
	/// Uses a 6 bit count.
	fn rcr_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Rotate 9 bits (CF, r/m8) right CL times.
	fn rcr_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) right imm8 times.
	fn rcr_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) right once.
	fn rcr_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Rotate 17 bits (CF, r/m16) right CL times.
	fn rcr_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Rotate 17 bits (CF, r/m16) right imm8 times.
	fn rcr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Rotate 17 bits (CF, r/m16) right once.
	fn rcr_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Rotate 33 bits (CF, r/m32) right CL times.
	fn rcr_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Rotate 33 bits (CF, r/m32) right imm8 times.
	fn rcr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Rotate 33 bits (CF, r/m32) right once.
	/// Uses a 6 bit count.
	fn rcr_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Rotate 65 bits (CF, r/m64) right CL times.
	/// Uses a 6 bit count.
	fn rcr_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Rotate 65 bits (CF, r/m64) right imm8 times.
	/// Uses a 6 bit count.
	fn rcr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Rotate 65 bits (CF, r/m64) right once.
	/// Uses a 6 bit count.
	fn rcr_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Rotate 9 bits (CF, r/m8) right CL times.
	fn rcr_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) right imm8 times.
	fn rcr_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) right once.
	fn rcr_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Rotate 9 bits (CF, r/m8) right CL times.
	fn rcr_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Rotate 9 bits (CF, r/m8) right imm8 times.
	fn rcr_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Rotate 9 bits (CF, r/m8) right once.
	fn rcr_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Load the 32-bit destination register with the FS base address.
	fn rdfsbase_Register32Bit(&mut self, arg0: Register32Bit);

	/// Load the 64-bit destination register with the FS base address.
	fn rdfsbase_Register64Bit(&mut self, arg0: Register64Bit);

	/// Load the 32-bit destination register with the GS base address.
	fn rdgsbase_Register32Bit(&mut self, arg0: Register32Bit);

	/// Load the 64-bit destination register with the GS base address.
	fn rdgsbase_Register64Bit(&mut self, arg0: Register64Bit);

	/// Read a 16-bit random number and store in the destination register.
	fn rdrand_Register16Bit(&mut self, arg0: Register16Bit);

	/// Read a 32-bit random number and store in the destination register.
	fn rdrand_Register32Bit(&mut self, arg0: Register32Bit);

	/// Read a 64-bit random number and store in the destination register.
	fn rdrand_Register64Bit(&mut self, arg0: Register64Bit);

	/// Input `(E)CX` words from port `DX` into ES:[(E)DI.].
	fn rep_ins_Any16BitMemory_DX(&mut self, arg0: Any16BitMemory, arg1: DX);

	/// Input `(E)CX` doublewords from port `DX` into ES:[(E)DI].
	fn rep_ins_Any32BitMemory_DX(&mut self, arg0: Any32BitMemory, arg1: DX);

	/// Input RCX default size from port `DX` into [RDI].
	fn rep_ins_Any64BitMemory_DX(&mut self, arg0: Any64BitMemory, arg1: DX);

	/// Input `(E)CX` bytes from port `DX` into ES:[(E)DI].
	fn rep_ins_Any8BitMemory_DX(&mut self, arg0: Any8BitMemory, arg1: DX);

	/// Input RCX bytes from port `DX` into [RDI].
	fn rep_ins_Any8BitMemory_DX_1(&mut self, arg0: Any8BitMemory, arg1: DX);

	/// Load `(E)CX` bytes from DS:[(E)SI] to AL.
	fn rep_lods_AL(&mut self, arg0: AL);

	/// Load RCX bytes from [RSI] to AL.
	fn rep_lods_AL_1(&mut self, arg0: AL);

	/// Load `(E)CX` words from DS:[(E)SI] to AX.
	fn rep_lods_AX(&mut self, arg0: AX);

	/// Load `(E)CX` doublewords from DS:[(E)SI] to EAX.
	fn rep_lods_EAX(&mut self, arg0: EAX);

	/// Load RCX quadwords from [RSI] to RAX.
	fn rep_lods_RAX(&mut self, arg0: RAX);

	/// Move `(E)CX` words from DS:[(E)SI] to ES:[(E)DI].
	fn rep_movs_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory);

	/// Move `(E)CX` doublewords from DS:[(E)SI] to ES:[(E)DI].
	fn rep_movs_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory);

	/// Move RCX quadwords from [RSI] to [RDI].
	fn rep_movs_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory);

	/// Move `(E)CX` bytes from DS:[(E)SI] to ES:[(E)DI].
	fn rep_movs(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Move RCX bytes from [RSI] to [RDI].
	fn rep_movs_Any8BitMemory_Any8BitMemory_1(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Output `(E)CX` words from `DS:[(E)SI]` to port `DX`.
	fn rep_outs_Any16BitMemory(&mut self, arg0: DX, arg1: Any16BitMemory);

	/// Output `(E)CX` doublewords from DS:[(E)SI] to port `DX`.
	fn rep_outs_Any32BitMemory(&mut self, arg0: DX, arg1: Any32BitMemory);

	/// Output RCX default size from [RSI] to port `DX`.
	fn rep_outs_Any64BitMemory(&mut self, arg0: DX, arg1: Any64BitMemory);

	/// Output `(E)CX` bytes from DS:[(E)SI] to port `DX`.
	fn rep_outs_Any8BitMemory(&mut self, arg0: DX, arg1: Any8BitMemory);

	/// Output RCX bytes from [RSI] to port `DX`.
	fn rep_outs_DX_Any8BitMemory_1(&mut self, arg0: DX, arg1: Any8BitMemory);

	/// Fill `(E)CX` words at ES:[(E)DI] with AX.
	fn rep_stos_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Fill `(E)CX` doublewords at ES:[(E)DI] with EAX.
	fn rep_stos_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Fill RCX quadwords at [RDI] with RAX.
	fn rep_stos_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Fill `(E)CX` bytes at ES:[(E)DI] with AL.
	fn rep_stos_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Fill RCX bytes at [RDI] with AL.
	fn rep_stos_Any8BitMemory_1(&mut self, arg0: Any8BitMemory);

	/// Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].
	fn repe_cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory);

	/// Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].
	fn repe_cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory);

	/// Find non-matching quadwords in [RDI] and [RSI].
	fn repe_cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory);

	/// Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].
	fn repe_cmps_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Find non-matching bytes in [RDI] and [RSI].
	fn repe_cmps_Any8BitMemory_Any8BitMemory_1(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Find non-AX word starting at ES:[(E)DI].
	fn repe_scas_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Find non-EAX doubleword starting at ES:[(E)DI].
	fn repe_scas_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Find non-RAX quadword starting at [RDI].
	fn repe_scas_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Find non-AL byte starting at ES:[(E)DI].
	fn repe_scas_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Find non-AL byte starting at [RDI].
	fn repe_scas_Any8BitMemory_1(&mut self, arg0: Any8BitMemory);

	/// Find matching words in ES:[(E)DI] and DS:[(E)SI].
	fn repne_cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory);

	/// Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].
	fn repne_cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory);

	/// Find matching doublewords in [RDI] and [RSI].
	fn repne_cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory);

	/// Find matching bytes in ES:[(E)DI] and DS:[(E)SI].
	fn repne_scas(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Find matching bytes in [RDI] and [RSI].
	fn repne_cmps_Any8BitMemory_Any8BitMemory_1(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory);

	/// Find AX, starting at ES:[(E)DI].
	fn repne_scas_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Find EAX, starting at ES:[(E)DI].
	fn repne_scas_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Find RAX, starting at [RDI].
	fn repne_scas_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Find AL, starting at ES:[(E)DI].
	fn repne_scas_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Find AL, starting at [RDI].
	fn repne_scas_Any8BitMemory_1(&mut self, arg0: Any8BitMemory);

	/// Near return to calling procedure.
	fn ret(&mut self);

	/// Far return to calling procedure.
	fn ret_Far(&mut self, arg0: Far);

	/// Near return to calling procedure and pop imm16 bytes from stack.
	fn ret_Immediate16Bit(&mut self, arg0: Immediate16Bit);

	/// Far return to calling procedure and pop imm16 bytes from stack.
	fn ret_Immediate16Bit_Far(&mut self, arg0: Immediate16Bit, arg1: Far);

	/// Rotate 16 bits r/m16 left CL times.
	fn rol_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Rotate 16 bits r/m16 left imm8 times.
	fn rol_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Rotate 16 bits r/m16 left once.
	fn rol_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Rotate 32 bits r/m32 left CL times.
	fn rol_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Rotate 32 bits r/m32 left imm8 times.
	fn rol_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Rotate 32 bits r/m32 left once.
	fn rol_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Rotate 64 bits r/m64 left CL times.
	/// Uses a 6 bit count.
	fn rol_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Rotate 64 bits r/m64 left imm8 times.
	/// Uses a 6 bit count.
	fn rol_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Rotate 64 bits r/m64 left once.
	/// Uses a 6 bit count.
	fn rol_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Rotate 8 bits r/m8 left CL times.
	fn rol_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Rotate 8 bits r/m8 left imm8 times.
	fn rol_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 left once.
	fn rol_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Rotate 16 bits r/m16 left CL times.
	fn rol_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Rotate 16 bits r/m16 left imm8 times.
	fn rol_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Rotate 16 bits r/m16 left once.
	fn rol_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Rotate 32 bits r/m32 left CL times.
	fn rol_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Rotate 32 bits r/m32 left imm8 times.
	fn rol_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Rotate 32 bits r/m32 left once.
	fn rol_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Rotate 64 bits r/m64 left CL times.
	/// Uses a 6 bit count.
	fn rol_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Rotate 64 bits r/m64 left imm8 times.
	/// Uses a 6 bit count.
	fn rol_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Rotate 64 bits r/m64 left once.
	/// Uses a 6 bit count.
	fn rol_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Rotate 8 bits r/m8 left CL times.
	fn rol_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Rotate 8 bits r/m8 left imm8 times.
	fn rol_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 left once.
	fn rol_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Rotate 8 bits r/m8 left CL times.
	fn rol_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Rotate 8 bits r/m8 left imm8 times.
	fn rol_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 left once.
	fn rol_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Rotate 16 bits r/m16 right CL times.
	fn ror_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Rotate 16 bits r/m16 right imm8 times.
	fn ror_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Rotate 16 bits r/m16 right once.
	fn ror_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Rotate 32 bits r/m32 right CL times.
	fn ror_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Rotate 32 bits r/m32 right imm8 times.
	fn ror_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Rotate 32 bits r/m32 right once.
	fn ror_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Rotate 64 bits r/m64 right CL times.
	/// Uses a 6 bit count.
	fn ror_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Rotate 64 bits r/m64 right imm8 times.
	/// Uses a 6 bit count.
	fn ror_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Rotate 64 bits r/m64 right once.
	/// Uses a 6 bit count.
	fn ror_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Rotate 8 bits r/m8 right CL times.
	fn ror_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Rotate 8 bits r/m16 right imm8 times.
	fn ror_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 right once.
	fn ror_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Rotate 16 bits r/m16 right CL times.
	fn ror_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Rotate 16 bits r/m16 right imm8 times.
	fn ror_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Rotate 16 bits r/m16 right once.
	fn ror_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Rotate 32 bits r/m32 right CL times.
	fn ror_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Rotate 32 bits r/m32 right imm8 times.
	fn ror_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Rotate 32 bits r/m32 right once.
	fn ror_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Rotate 64 bits r/m64 right CL times.
	/// Uses a 6 bit count.
	fn ror_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Rotate 64 bits r/m64 right imm8 times.
	/// Uses a 6 bit count.
	fn ror_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Rotate 64 bits r/m64 right once.
	/// Uses a 6 bit count.
	fn ror_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Rotate 8 bits r/m8 right CL times.
	fn ror_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Rotate 8 bits r/m16 right imm8 times.
	fn ror_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 right once.
	fn ror_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Rotate 8 bits r/m8 right CL times.
	fn ror_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Rotate 8 bits r/m16 right imm8 times.
	fn ror_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Rotate 8 bits r/m8 right once.
	fn ror_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags.
	fn rorx_Register32Bit_Any32BitMemory_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags.
	fn rorx_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags.
	fn rorx_Register64Bit_Any64BitMemory_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags.
	fn rorx_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit);

	/// Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundsd_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: Immediate8Bit);

	/// Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundsd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundss_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit);

	/// Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn roundss_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn rsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn rsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
	fn rsqrtss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
	fn rsqrtss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.
	fn sahf(&mut self);

	/// Multiply r/m16 by 2, CL times.
	fn sal_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Multiply r/m16 by 2, imm8 times.
	fn sal_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m16 by 2, once.
	fn sal_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn sal_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn sal_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m32 by 2, once.
	fn sal_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Multiply r/m64 by 2, CL times.
	fn sal_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Multiply r/m64 by 2, imm8 times.
	fn sal_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m64 by 2, once.
	fn sal_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn sal_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn sal_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn sal_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Multiply r/m16 by 2, CL times.
	fn sal_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Multiply r/m16 by 2, imm8 times.
	fn sal_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Multiply r/m16 by 2, once.
	fn sal_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn sal_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn sal_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Multiply r/m32 by 2, once.
	fn sal_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Multiply r/m64 by 2, CL times.
	fn sal_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Multiply r/m64 by 2, imm8 times.
	fn sal_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Multiply r/m64 by 2, once.
	fn sal_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn sal_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn sal_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn sal_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn sal_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn sal_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn sal_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Signed divide r/m16 by 2, CL times.
	fn sar_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Signed divide r/m16 by 2, imm8 times.
	fn sar_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Signed divide r/m16 by 2, once.
	fn sar_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Signed divide r/m32 by 2, CL times.
	fn sar_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Signed divide r/m32 by 2, imm8 times.
	fn sar_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Signed divide r/m32 by 2, once.
	fn sar_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Signed divide r/m32 by 2, CL times.
	fn sar_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Signed divide r/m32 by 2, imm8 times.
	fn sar_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Signed divide r/m32 by 2, once.
	fn sar_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Signed divide r/m8 by 2, CL times.
	fn sar_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Signed divide r/m8 by 2, imm8 time.
	fn sar_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Signed divide r/m8 by 2, once.
	fn sar_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Signed divide r/m16 by 2, CL times.
	fn sar_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Signed divide r/m16 by 2, imm8 times.
	fn sar_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Signed divide r/m16 by 2, once.
	fn sar_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Signed divide r/m32 by 2, CL times.
	fn sar_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Signed divide r/m32 by 2, imm8 times.
	fn sar_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Signed divide r/m32 by 2, once.
	fn sar_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Signed divide r/m32 by 2, CL times.
	fn sar_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Signed divide r/m32 by 2, imm8 times.
	fn sar_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Signed divide r/m32 by 2, once.
	fn sar_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Signed divide r/m8 by 2, CL times.
	fn sar_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Signed divide r/m8 by 2, imm8 time.
	fn sar_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Signed divide r/m8 by 2, once.
	fn sar_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Signed divide r/m8 by 2, CL times.
	fn sar_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Signed divide r/m8 by 2, imm8 time.
	fn sar_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Signed divide r/m8 by 2, once.
	fn sar_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Shift r/m32 arithmetically right with count specified in r32b.
	fn sarx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit);

	/// Shift r/m32 arithmetically right with count specified in r32b.
	fn sarx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Shift r/m64 arithmetically right with count specified in r64b.
	fn sarx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit);

	/// Shift r/m64 arithmetically right with count specified in r64b.
	fn sarx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Subtract with borrow imm8 from AL.
	fn sbb_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Subtract with borrow imm16 from AX.
	fn sbb_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// Subtract with borrow imm32 from EAX.
	fn sbb_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// Subtract with borrow imm16 from r/m16.
	fn sbb_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Subtract with borrow sign-extended imm8 from r/m16.
	fn sbb_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Subtract with borrow r16 from r/m16.
	fn sbb_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Subtract with borrow imm32 from r/m32.
	fn sbb_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Subtract with borrow sign-extended imm8 from r/m32.
	fn sbb_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Subtract with borrow r32 from r/m32.
	fn sbb_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
	fn sbb_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Subtract with borrow sign-extended imm8 from r/m64.
	fn sbb_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Subtract with borrow r64 from r/m64.
	fn sbb_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Subtract with borrow imm8 from r/m8.
	fn sbb_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract with borrow imm16 from r/m16.
	fn sbb_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Subtract with borrow sign-extended imm8 from r/m16.
	fn sbb_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Subtract with borrow r/m16 from r16.
	fn sbb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Subtract with borrow r16 from r/m16.
	fn sbb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Subtract with borrow r/m16 from r16.
	fn sbb_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Subtract with borrow imm32 from r/m32.
	fn sbb_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Subtract with borrow sign-extended imm8 from r/m32.
	fn sbb_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Subtract with borrow r/m32 from r32.
	fn sbb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Subtract with borrow r32 from r/m32.
	fn sbb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Subtract with borrow r/m32 from r32.
	fn sbb_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
	fn sbb_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Subtract with borrow sign-extended imm8 from r/m64.
	fn sbb_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Subtract with borrow r/m64 from r64.
	fn sbb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Subtract with borrow r64 from r/m64.
	fn sbb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Subtract with borrow r/m64 from r64.
	fn sbb_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Subtract with borrow imm8 from r/m8.
	fn sbb_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract with borrow sign-extended imm.32 to 64-bits from RAX.
	fn sbb_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// Subtract with borrow imm8 from r/m8.
	fn sbb_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Subtract with borrow r8 from r/m8.
	fn sbb_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract with borrow r/m8 from r8.
	fn sbb_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Compare AX with word at ES:(E)DI or RDI, then set status flags.
	fn scas_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Compare EAX with doubleword at ES(E)DI or RDI then set status flags.
	fn scas_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Compare RAX with quadword at RDI or EDI then set status flags.
	fn scas_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Compare AL with byte at ES:(E)DI or RDI, then set status flags.
	fn scas_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Compare AL with byte at ES:(E)DI or RDI then set status flags.
	fn scasb(&mut self);

	/// Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.
	fn scasd(&mut self);

	/// Compare RAX with quadword at RDI or EDI then set status flags.
	fn scasq(&mut self);

	/// Compare AX with word at ES:(E)DI or RDI then set status flags.
	fn scasw(&mut self);

	/// Set byte if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn seta_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn seta_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if above (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn seta_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if above or equal (Carry Flag (CF) is 0).
	fn setae_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if above or equal (Carry Flag (CF) is 0).
	fn setae_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if above or equal (Carry Flag (CF) is 0).
	fn setae_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if below (Carry Flag (CF) is 1).
	fn setb_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if below (Carry Flag (CF) is 1).
	fn setb_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if below (Carry Flag (CF) is 1).
	fn setb_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setbe_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setbe_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if below or equal (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setbe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if carry (Carry Flag (CF) is 1).
	fn setc_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if carry (Carry Flag (CF) is 1).
	fn setc_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if carry (Carry Flag (CF) is 1).
	fn setc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if equal (Zero Flag (ZF) is 1).
	fn sete_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if equal (Zero Flag (ZF) is 1).
	fn sete_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if equal (Zero Flag (ZF) is 1).
	fn sete_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setg_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setg_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if greater (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setg_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if greater or equal (`SF == OF`).
	fn setge_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if greater or equal (`SF == OF`).
	fn setge_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if greater or equal (`SF == OF`).
	fn setge_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if less (`SF != OF`).
	fn setl_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if less (`SF != OF`).
	fn setl_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if less (`SF != OF`).
	fn setl_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setle_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setle_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if less or equal (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setle_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setna_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setna_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not above (Carry Flag (CF) is 1 or Zero Flag (ZF) is 1).
	fn setna_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not above or equal (Carry Flag (CF) is 1).
	fn setnae_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not above or equal (Carry Flag (CF) is 1).
	fn setnae_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not above or equal (Carry Flag (CF) is 1).
	fn setnae_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not below (Carry Flag (CF) is 0).
	fn setnb_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not below (Carry Flag (CF) is 0).
	fn setnb_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not below (Carry Flag (CF) is 0).
	fn setnb_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn setnbe_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn setnbe_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not below or equal (Carry Flag (CF) is 0 and Zero Flag (ZF) is 0).
	fn setnbe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not carry (Carry Flag (CF) is 0).
	fn setnc_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not carry (Carry Flag (CF) is 0).
	fn setnc_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not carry (Carry Flag (CF) is 0).
	fn setnc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not equal (Zero Flag (ZF) is 0).
	fn setne_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not equal (Zero Flag (ZF) is 0).
	fn setne_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not equal (Zero Flag (ZF) is 0).
	fn setne_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setng_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setng_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not greater (Zero Flag (ZF) is 1 or `SF != OF`).
	fn setng_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not greater or equal (`SF != OF`).
	fn setnge_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not greater or equal (`SF != OF`).
	fn setnge_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not greater or equal (`SF != OF`).
	fn setnge_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not less (`SF == OF`).
	fn setnl_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not less (`SF == OF`).
	fn setnl_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not less (`SF == OF`).
	fn setnl_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setnle_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setnle_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not less or equal (Zero Flag (ZF) is 0 and `SF == OF`).
	fn setnle_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not overflow (OF=0).
	fn setno_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not overflow (OF=0).
	fn setno_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not overflow (OF=0).
	fn setno_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not parity (Parity Flag (PF) is 0).
	fn setnp_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not parity (Parity Flag (PF) is 0).
	fn setnp_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not parity (Parity Flag (PF) is 0).
	fn setnp_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not sign (Sign Flag (SF) is 0).
	fn setns_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not sign (Sign Flag (SF) is 0).
	fn setns_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not sign (Sign Flag (SF) is 0).
	fn setns_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if not zero (Zero Flag (ZF) is 0).
	fn setnz_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if not zero (Zero Flag (ZF) is 0).
	fn setnz_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if not zero (Zero Flag (ZF) is 0).
	fn setnz_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if overflow (Overflow Flag (OF) is 1).
	fn seto_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if overflow (Overflow Flag (OF) is 1).
	fn seto_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if overflow (Overflow Flag (OF) is 1).
	fn seto_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if parity (Parity Flag (PF) is 1).
	fn setp_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if parity (Parity Flag (PF) is 1).
	fn setp_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if parity (Parity Flag (PF) is 1).
	fn setp_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if parity even (Parity Flag (PF) is 1).
	fn setpe_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if parity even (Parity Flag (PF) is 1).
	fn setpe_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if parity even (Parity Flag (PF) is 1).
	fn setpe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if parity odd (Parity Flag (PF) is 0).
	fn setpo_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if parity odd (Parity Flag (PF) is 0).
	fn setpo_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if parity odd (Parity Flag (PF) is 0).
	fn setpo_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if sign (SF=1).
	fn sets_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if sign (SF=1).
	fn sets_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if sign (SF=1).
	fn sets_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Set byte if zero (Zero Flag (ZF) is 1).
	fn setz_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set byte if zero (Zero Flag (ZF) is 1).
	fn setz_Register8Bit(&mut self, arg0: Register8Bit);

	/// Set byte if zero (Zero Flag (ZF) is 1).
	fn setz_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit);

	/// Serializes store operations.
	fn sfence(&mut self);

	/// Multiply r/m16 by 2, CL times.
	fn shl_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Multiply r/m16 by 2, imm8 times.
	fn shl_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m16 by 2, once.
	fn shl_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn shl_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn shl_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m32 by 2, once.
	fn shl_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn shl_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn shl_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m64 by 2, once.
	fn shl_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn shl_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn shl_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn shl_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Multiply r/m16 by 2, CL times.
	fn shl_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Multiply r/m16 by 2, imm8 times.
	fn shl_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Multiply r/m16 by 2, once.
	fn shl_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn shl_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn shl_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Multiply r/m32 by 2, once.
	fn shl_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Multiply r/m32 by 2, CL times.
	fn shl_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Multiply r/m32 by 2, imm8 times.
	fn shl_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Multiply r/m64 by 2, once.
	fn shl_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn shl_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn shl_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn shl_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Multiply r/m8 by 2, CL times.
	fn shl_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Multiply r/m8 by 2, imm8 times.
	fn shl_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Multiply r/m8 by 2, once.
	fn shl_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Shift r/m16 to left CL places while shifting bits from r16 in from the right.
	fn shld_Any16BitMemory_Register16Bit_CL(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: CL);

	/// Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
	fn shld_Any16BitMemory_Register16Bit_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: Immediate8Bit);

	/// Shift r/m32 to left CL places while shifting bits from r32 in from the right.
	fn shld_Any32BitMemory_Register32Bit_CL(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: CL);

	/// Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
	fn shld_Any32BitMemory_Register32Bit_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Shift r/m64 to left CL places while shifting bits from r64 in from the right.
	fn shld_Any64BitMemory_Register64Bit_CL(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: CL);

	/// Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
	fn shld_Any64BitMemory_Register64Bit_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: Immediate8Bit);

	/// Shift r/m16 to left CL places while shifting bits from r16 in from the right.
	fn shld_Register16Bit_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: CL);

	/// Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
	fn shld_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit);

	/// Shift r/m32 to left CL places while shifting bits from r32 in from the right.
	fn shld_Register32Bit_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: CL);

	/// Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
	fn shld_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Shift r/m64 to left CL places while shifting bits from r64 in from the right.
	fn shld_Register64Bit_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: CL);

	/// Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
	fn shld_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit);

	/// Shift r/m32 logically left with count specified in r32b.
	fn shlx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit);

	/// Shift r/m32 logically left with count specified in r32b.
	fn shlx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Shift r/m64 logically left with count specified in r64b.
	fn shlx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit);

	/// Shift r/m64 logically left with count specified in r64b.
	fn shlx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Unsigned divide r/m16 by 2, CL times.
	fn shr_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL);

	/// Unsigned divide r/m16 by 2, imm8 times.
	fn shr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Unsigned divide r/m16 by 2, once.
	fn shr_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One);

	/// Unsigned divide r/m32 by 2, CL times.
	fn shr_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL);

	/// Unsigned divide r/m32 by 2, imm8 times.
	fn shr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Unsigned divide r/m32 by 2, once.
	fn shr_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One);

	/// Unsigned divide r/m32 by 2, CL times.
	fn shr_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL);

	/// Unsigned divide r/m32 by 2, imm8 times.
	fn shr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Unsigned divide r/m32 by 2, once.
	fn shr_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One);

	/// Unsigned divide r/m8 by 2, CL times.
	fn shr_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL);

	/// Unsigned divide r/m8 by 2, imm8 times.
	fn shr_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Unsigned divide r/m8 by 2, once.
	fn shr_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One);

	/// Unsigned divide r/m16 by 2, CL times.
	fn shr_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL);

	/// Unsigned divide r/m16 by 2, imm8 times.
	fn shr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Unsigned divide r/m16 by 2, once.
	fn shr_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One);

	/// Unsigned divide r/m32 by 2, CL times.
	fn shr_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL);

	/// Unsigned divide r/m32 by 2, imm8 times.
	fn shr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Unsigned divide r/m32 by 2, once.
	fn shr_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One);

	/// Unsigned divide r/m32 by 2, CL times.
	fn shr_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL);

	/// Unsigned divide r/m32 by 2, imm8 times.
	fn shr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Unsigned divide r/m32 by 2, once.
	fn shr_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One);

	/// Unsigned divide r/m8 by 2, CL times.
	fn shr_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL);

	/// Unsigned divide r/m8 by 2, imm8 times.
	fn shr_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Unsigned divide r/m8 by 2, once.
	fn shr_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One);

	/// Unsigned divide r/m8 by 2, CL times.
	fn shr_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL);

	/// Unsigned divide r/m8 by 2, imm8 times.
	fn shr_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Unsigned divide r/m8 by 2, once.
	fn shr_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One);

	/// Shift r/m16 to right CL places while shifting bits from r16 in from the left.
	fn shrd_Any16BitMemory_Register16Bit_CL(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: CL);

	/// Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
	fn shrd_Any16BitMemory_Register16Bit_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: Immediate8Bit);

	/// Shift r/m32 to right CL places while shifting bits from r32 in from the left.
	fn shrd_Any32BitMemory_Register32Bit_CL(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: CL);

	/// Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
	fn shrd_Any32BitMemory_Register32Bit_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Shift r/m64 to right CL places while shifting bits from r64 in from the left.
	fn shrd_Any64BitMemory_Register64Bit_CL(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: CL);

	/// Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
	fn shrd_Any64BitMemory_Register64Bit_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: Immediate8Bit);

	/// Shift r/m16 to right CL places while shifting bits from r16 in from the left.
	fn shrd_Register16Bit_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: CL);

	/// Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
	fn shrd_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit);

	/// Shift r/m32 to right CL places while shifting bits from r32 in from the left.
	fn shrd_Register32Bit_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: CL);

	/// Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
	fn shrd_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit);

	/// Shift r/m64 to right CL places while shifting bits from r64 in from the left.
	fn shrd_Register64Bit_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: CL);

	/// Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
	fn shrd_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit);

	/// Shift r/m32 logically right with count specified in r32b.
	fn shrx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit);

	/// Shift r/m32 logically right with count specified in r32b.
	fn shrx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit);

	/// Shift r/m64 logically right with count specified in r64b.
	fn shrx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit);

	/// Shift r/m64 logically right with count specified in r64b.
	fn shrx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit);

	/// Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
	fn shufpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
	fn shufpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
	fn shufps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
	fn shufps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn sqrtpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn sqrtpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn sqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
	fn sqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
	fn sqrtsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
	fn sqrtsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
	fn sqrtss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
	fn sqrtss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Set CF flag.
	fn stc(&mut self);

	/// Set DF flag.
	fn std(&mut self);

	/// Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.
	fn sti(&mut self);

	/// Store contents of MXCSR register to m32.
	fn stmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
	fn stos_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
	fn stos_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Store RAX at address RDI or EDI.
	fn stos_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
	fn stos_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.
	fn stosb(&mut self);

	/// For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.
	fn stosd(&mut self);

	/// Store RAX at address RDI or EDI.
	fn stosq(&mut self);

	/// For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.
	fn stosw(&mut self);

	/// Subtract imm8 from AL.
	fn sub_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// Subtract imm16 from AX.
	fn sub_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// Subtract imm32 from EAX.
	fn sub_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// Subtract imm16 from r/m16.
	fn sub_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// Subtract sign-extended imm8 from r/m16.
	fn sub_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// Subtract r16 from r/m16.
	fn sub_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Subtract imm32 from r/m32.
	fn sub_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// Subtract sign-extended imm8 from r/m32.
	fn sub_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// Subtract r32 from r/m32.
	fn sub_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Subtract imm32 sign-extended to 64-bits from r/m64.
	fn sub_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// Subtract sign-extended imm8 from r/m64.
	fn sub_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// Subtract r64 from r/m64.
	fn sub_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Subtract imm8 from r/m8.
	fn sub_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// Subtract r8 from r/m8.
	fn sub_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Subtract r8 from r/m8.
	fn sub_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract imm16 from r/m16.
	fn sub_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// Subtract sign-extended imm8 from r/m16.
	fn sub_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// Subtract r/m16 from r16.
	fn sub_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Subtract r16 from r/m16.
	fn sub_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Subtract r/m16 from r16.
	fn sub_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Subtract imm32 from r/m32.
	fn sub_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// Subtract sign-extended imm8 from r/m32.
	fn sub_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// Subtract r/m32 from r32.
	fn sub_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Subtract r32 from r/m32.
	fn sub_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Subtract r/m32 from r32.
	fn sub_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Subtract imm32 sign-extended to 64-bits from r/m64.
	fn sub_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// Subtract sign-extended imm8 from r/m64.
	fn sub_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// Subtract r/m64 from r64.
	fn sub_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Subtract r64 from r/m64.
	fn sub_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Subtract r/m64 from r64.
	fn sub_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Subtract imm8 from r/m8.
	fn sub_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// Subtract r/m8 from r8.
	fn sub_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Subtract r8 from r/m8.
	fn sub_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Subtract r/m8 from r8.
	fn sub_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Subtract r8 from r/m8.
	fn sub_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract r/m8 from r8.
	fn sub_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract imm32 sign-extended to 64-bits from RAX.
	fn sub_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// Subtract imm8 from r/m8.
	fn sub_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// Subtract r/m8 from r8.
	fn sub_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Subtract r8 from r/m8.
	fn sub_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Subtract r/m8 from r8.
	fn sub_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Subtract r8 from r/m8.
	fn sub_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract r/m8 from r8.
	fn sub_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
	fn subpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
	fn subpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
	fn subps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
	fn subps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
	fn subsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
	fn subsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
	fn subss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
	fn subss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Exchanges the current GS base register value with the value contained in MSR address C0000102H.
	fn swapgs(&mut self);

	/// Fast call to privilege level 0 system procedures.
	fn syscall(&mut self);

	/// Fast call to privilege level 0 system procedures.
	fn sysenter(&mut self);

	/// Fast return to privilege level 3 user code.
	fn sysexit(&mut self);

	/// Fast return to 64-bit mode privilege level 3 user code.
	fn sysexit_PrefixRexW(&mut self, arg0: PrefixRexW);

	/// Return to compatibility mode from fast system call.
	fn sysret(&mut self);

	/// Return to 64-bit mode from fast system call.
	fn sysret_PrefixRexW(&mut self, arg0: PrefixRexW);

	/// AND imm8 with AL; set SF, ZF, PF according to result.
	fn test_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// AND imm16 with AX; set SF, ZF, PF according to result.
	fn test_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// AND imm32 with EAX; set SF, ZF, PF according to result.
	fn test_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// AND imm16 with r/m16; set SF, ZF, PF according to result.
	fn test_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// AND r16 with r/m16; set SF, ZF, PF according to result.
	fn test_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// AND imm32 with r/m32; set SF, ZF, PF according to result.
	fn test_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// AND r32 with r/m32; set SF, ZF, PF according to result.
	fn test_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
	fn test_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// AND r64 with r/m64; set SF, ZF, PF according to result.
	fn test_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// AND imm8 with r/m8; set SF, ZF, PF according to result.
	fn test_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// AND imm16 with r/m16; set SF, ZF, PF according to result.
	fn test_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// AND r16 with r/m16; set SF, ZF, PF according to result.
	fn test_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// AND imm32 with r/m32; set SF, ZF, PF according to result.
	fn test_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// AND r32 with r/m32; set SF, ZF, PF according to result.
	fn test_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
	fn test_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// AND r64 with r/m64; set SF, ZF, PF according to result.
	fn test_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// AND imm8 with r/m8; set SF, ZF, PF according to result.
	fn test_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.
	fn test_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// AND imm8 with r/m8; set SF, ZF, PF according to result.
	fn test_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// AND r8 with r/m8; set SF, ZF, PF according to result.
	fn test_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Count the number of trailing zero bits in r/m16, return result in r16.
	fn tzcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Count the number of trailing zero bits in r/m16, return result in r16.
	fn tzcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Count the number of trailing zero bits in r/m32, return result in r32.
	fn tzcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Count the number of trailing zero bits in r/m32, return result in r32.
	fn tzcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Count the number of trailing zero bits in r/m64, return result in r64.
	fn tzcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Count the number of trailing zero bits in r/m64, return result in r64.
	fn tzcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
	fn ucomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
	fn ucomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
	fn ucomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
	fn ucomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Raise invalid opcode exception.
	fn ud2(&mut self);

	/// Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
	fn unpckhpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
	fn unpckhpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
	fn unpckhps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
	fn unpckhps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
	fn unpcklpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
	fn unpcklpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
	fn unpcklps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
	fn unpcklps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
	fn vaddsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
	fn vaddsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
	fn vaddss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.
	fn vaddss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vaddsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vaddsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
	fn vaesdec_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
	fn vaesdec_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
	fn vaesdeclast_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.
	fn vaesdeclast_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1.
	fn vaesenc_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1.
	fn vaesenc_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.
	fn vaesenclast_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.
	fn vaesenclast_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
	fn vaesimc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.
	fn vaesimc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
	fn vaeskeygenassist_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.
	fn vaeskeygenassist_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vandnpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vandnpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vandnpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vandnpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vandnps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vandnps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vandnps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vandnps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vandpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vandpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vandpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vandpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vandps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vandps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vandps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vandps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Select packed double-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.
	fn vblendpd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Select packed double-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.
	fn vblendpd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Select packed double-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
	fn vblendpd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Select packed double-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
	fn vblendpd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.
	fn vblendps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.
	fn vblendps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
	fn vblendps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.
	fn vblendps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Conditionally copy double-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.
	fn vblendvpd_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister);

	/// Conditionally copy double-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.
	fn vblendvpd_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister);

	/// Conditionally copy double-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.
	fn vblendvpd_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM);

	/// Conditionally copy double-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.
	fn vblendvpd_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM);

	/// Conditionally copy single-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.
	fn vblendvps_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister);

	/// Conditionally copy single-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.
	fn vblendvps_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister);

	/// Conditionally copy single-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.
	fn vblendvps_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM);

	/// Conditionally copy single-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.
	fn vblendvps_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM);

	/// Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1.
	fn vbroadcastf128_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1.
	fn vbroadcasti128_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Broadcast double-precision floating-point element in mem to four locations in ymm1.
	fn vbroadcastsd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Broadcast low double-precision floating-point element in the source operand to four locations in ymm1.
	fn vbroadcastsd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Broadcast single-precision floating-point element in mem to four locations in xmm1.
	fn vbroadcastss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Broadcast the low single-precision floating- point element in the source operand to four locations in xmm1.
	fn vbroadcastss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Broadcast single-precision floating-point element in mem to eight locations in ymm1.
	fn vbroadcastss_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory);

	/// Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1.
	fn vbroadcastss_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Compare packed double-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmppd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Compare packed double-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmppd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Compare packed double-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmppd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Compare packed double-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmppd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Compare packed single-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmpps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Compare packed single-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmpps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Compare packed single-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmpps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Compare packed single-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.
	fn vcmpps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.
	fn vcmpsd_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit);

	/// Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.
	fn vcmpsd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.
	fn vcmpss_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit);

	/// Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.
	fn vcmpss_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn vcomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn vcomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn vcomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn vcomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1.
	fn vcvtdq2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1.
	fn vcvtdq2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed signed doubleword integers from ymm2/mem to four packed double-precision floating-point values in ymm1.
	fn vcvtdq2pd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Convert four packed signed doubleword integers from ymm2/mem to four packed double-precision floating-point values in ymm1.
	fn vcvtdq2pd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1.
	fn vcvtdq2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1.
	fn vcvtdq2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1.
	fn vcvtdq2ps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1.
	fn vcvtdq2ps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1.
	fn vcvtpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1.
	fn vcvtpd2dq_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1.
	fn vcvtpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1.
	fn vcvtpd2dq_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two single- precision floating-point values in xmm1.
	fn vcvtpd2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four single- precision floating-point values in xmm1.
	fn vcvtpd2ps_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two single- precision floating-point values in xmm1.
	fn vcvtpd2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four single- precision floating-point values in xmm1.
	fn vcvtpd2ps_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM);

	/// Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1.
	fn vcvtph2ps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1.
	fn vcvtph2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1.
	fn vcvtph2ps_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1.
	fn vcvtph2ps_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1.
	fn vcvtps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1.
	fn vcvtps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1.
	fn vcvtps2dq_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1.
	fn vcvtps2dq_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Convert two packed single-precision floating- point values in xmm2/mem to two packed double-precision floating-point values in xmm1.
	fn vcvtps2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Convert two packed single-precision floating- point values in xmm2/mem to two packed double-precision floating-point values in xmm1.
	fn vcvtps2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed single-precision floating- point values in xmm2/mem to four packed double-precision floating-point values in ymm1.
	fn vcvtps2pd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Convert four packed single-precision floating- point values in xmm2/mem to four packed double-precision floating-point values in ymm1.
	fn vcvtps2pd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Convert eight packed single-precision floating-point value in ymm2 to packed half-precision (16-bit) floating-point value in xmm1/mem.
	/// Immediate8Bit provides rounding controls.
	fn vcvtps2ph_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit);

	/// Convert four packed single-precision float- ing-point value in xmm2 to packed half- precision (16-bit) floating-point value in xmm1/mem.
	/// Immediate8Bit provides rounding con- trols.
	fn vcvtps2ph_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Convert four packed single-precision float- ing-point value in xmm2 to packed half- precision (16-bit) floating-point value in xmm1/mem.
	/// Immediate8Bit provides rounding con- trols.
	fn vcvtps2ph_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Convert eight packed single-precision floating-point value in ymm2 to packed half-precision (16-bit) floating-point value in xmm1/mem.
	/// Immediate8Bit provides rounding controls.
	fn vcvtps2ph_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.
	fn vcvtsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.
	fn vcvtsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.
	fn vcvtsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.
	fn vcvtsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2.
	fn vcvtsd2ss_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2.
	fn vcvtsd2ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1.
	fn vcvtsi2sd_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1.
	fn vcvtsi2sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1.
	fn vcvtsi2sd_XMMRegister_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit);

	/// Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1.
	fn vcvtsi2sd_XMMRegister_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit);

	/// Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1.
	fn vcvtsi2ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1.
	fn vcvtsi2ss_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1.
	fn vcvtsi2ss_XMMRegister_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit);

	/// Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1.
	fn vcvtsi2ss_XMMRegister_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit);

	/// Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2.
	fn vcvtss2sd_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2.
	fn vcvtss2sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.
	fn vcvtss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.
	fn vcvtss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64.
	fn vcvtss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64.
	fn vcvtss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.
	fn vcvttpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.
	fn vcvttpd2dq_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory);

	/// Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.
	fn vcvttpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.
	fn vcvttpd2dq_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM);

	/// Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.
	fn vcvttps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.
	fn vcvttps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.
	fn vcvttps2dq_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.
	fn vcvttps2dq_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.
	fn vcvttsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory);

	/// Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.
	fn vcvttsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.
	fn vcvttsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.
	fn vcvttsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.
	fn vcvttss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.
	fn vcvttss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.
	fn vcvttss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory);

	/// Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.
	fn vcvttss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
	fn vdivpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
	fn vdivpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
	fn vdivpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
	fn vdivpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
	fn vdivps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.
	fn vdivps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
	fn vdivps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.
	fn vdivps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64.
	fn vdivsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64.
	fn vdivsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32.
	fn vdivss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32.
	fn vdivss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Selectively multiply packed DP floating-point values from xmm2 with packed DP floating- point values from xmm3, add and selectively store the packed DP floating-point values to xmm1.
	fn vdppd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Selectively multiply packed DP floating-point values from xmm2 with packed DP floating- point values from xmm3, add and selectively store the packed DP floating-point values to xmm1.
	fn vdppd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1.
	fn vdpps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1.
	fn vdpps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1.
	fn vdpps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1.
	fn vdpps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Set Zero Flag (ZF) is 1 if segment specified with r/m16 can be read.
	fn verr_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Set Zero Flag (ZF) is 1 if segment specified with r/m16 can be read.
	fn verr_Register16Bit(&mut self, arg0: Register16Bit);

	/// Set Zero Flag (ZF) is 1 if segment specified with r/m16 can be written.
	fn verw_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Set Zero Flag (ZF) is 1 if segment specified with r/m16 can be written.
	fn verw_Register16Bit(&mut self, arg0: Register16Bit);

	/// Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem.
	fn vextractf128_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit);

	/// Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem.
	fn vextractf128_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit);

	/// Extract 128 bits of integer data from ymm2 and store results in xmm1/mem.
	fn vextracti128_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit);

	/// Extract 128 bits of integer data from ymm2 and store results in xmm1/mem.
	fn vextracti128_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit);

	/// Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32.
	/// Zero extend the results in 64-bit register if applicable.
	fn vextractps_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32.
	/// Zero extend the results in 64-bit register if applicable.
	fn vextractps_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
	fn vfmadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
	fn vfmadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
	fn vfmadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.
	fn vfmadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.
	fn vfmadd132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
	fn vfmadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
	fn vfmadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
	fn vfmadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.
	fn vfmadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.
	fn vfmadd213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
	fn vfmadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
	fn vfmadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
	fn vfmadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.
	fn vfmadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.
	fn vfmadd231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
	fn vfmaddsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
	fn vfmaddsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
	fn vfmaddsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
	fn vfmaddsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
	fn vfmaddsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.
	fn vfmaddsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
	fn vfmaddsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.
	fn vfmaddsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
	fn vfmaddsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
	fn vfmaddsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
	fn vfmaddsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
	fn vfmaddsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
	fn vfmaddsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.
	fn vfmaddsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
	fn vfmaddsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.
	fn vfmaddsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
	fn vfmaddsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
	fn vfmaddsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
	fn vfmaddsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
	fn vfmaddsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
	fn vfmaddsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.
	fn vfmaddsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
	fn vfmaddsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.
	fn vfmaddsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
	fn vfmsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
	fn vfmsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
	fn vfmsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.
	fn vfmsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.
	fn vfmsub132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.
	fn vfmsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.
	fn vfmsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.
	fn vfmsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.
	fn vfmsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.
	fn vfmsub213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
	fn vfmsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
	fn vfmsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
	fn vfmsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.
	fn vfmsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.
	fn vfmsub231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
	fn vfmsubadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
	fn vfmsubadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
	fn vfmsubadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
	fn vfmsubadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
	fn vfmsubadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.
	fn vfmsubadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
	fn vfmsubadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.
	fn vfmsubadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
	fn vfmsubadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
	fn vfmsubadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
	fn vfmsubadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
	fn vfmsubadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
	fn vfmsubadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.
	fn vfmsubadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
	fn vfmsubadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.
	fn vfmsubadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
	fn vfmsubadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
	fn vfmsubadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
	fn vfmsubadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
	fn vfmsubadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
	fn vfmsubadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.
	fn vfmsubadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
	fn vfmsubadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.
	fn vfmsubadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
	fn vfnmadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
	fn vfnmadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
	fn vfnmadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.
	fn vfnmadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.
	fn vfnmadd132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.
	fn vfnmadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.
	fn vfnmadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.
	fn vfnmadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.
	fn vfnmadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.
	fn vfnmadd213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
	fn vfnmadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
	fn vfnmadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
	fn vfnmadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.
	fn vfnmadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.
	fn vfnmadd231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
	fn vfnmsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
	fn vfnmsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
	fn vfnmsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.
	fn vfnmsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.
	fn vfnmsub132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
	fn vfnmsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
	fn vfnmsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
	fn vfnmsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.
	fn vfnmsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.
	fn vfnmsub213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
	fn vfnmsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
	fn vfnmsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
	fn vfnmsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.
	fn vfnmsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.
	fn vfnmsub231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vgatherdpd_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister);

	/// Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vgatherdpd_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM);

	/// Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vgatherdps_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister);

	/// Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vgatherdps_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM);

	/// Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vgatherqpd_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister);

	/// Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vgatherqpd_YMM_Any64BitMemory_YMM(&mut self, arg0: YMM, arg1: Any64BitMemory, arg2: YMM);

	/// Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vgatherqps_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister);

	/// Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vgatherqps_XMMRegister_Any64BitMemory_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg3: XMMRegister);

	/// Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem.
	fn vhaddpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem.
	fn vhaddpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem.
	fn vhaddpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem.
	fn vhaddpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem.
	fn vhaddps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem.
	fn vhaddps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem.
	fn vhaddps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem.
	fn vhaddps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem.
	fn vhsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem.
	fn vhsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem.
	fn vhsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem.
	fn vhsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem.
	fn vhsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem.
	fn vhsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem.
	fn vhsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem.
	fn vhsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Insert a single precision floating-point value selected by imm8 from xmm3/m128 into ymm2 at the specified destination element specified by imm8 and zero out destination elements in ymm1 as indicated in imm8.
	fn vinsertf128_YMM_YMM_Any128BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Insert a single precision floating-point value selected by imm8 from xmm3/m128 into ymm2 at the specified destination element specified by imm8 and zero out destination elements in ymm1 as indicated in imm8.
	fn vinsertf128_YMM_YMM_XMMRegister_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Insert 128-bits of integer data from xmm3/mem and the remaining values from ymm2 into ymm1.
	fn vinserti128_YMM_YMM_Any128BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Insert 128-bits of integer data from xmm3/mem and the remaining values from ymm2 into ymm1.
	fn vinserti128_YMM_YMM_XMMRegister_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
	fn vinsertps_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit);

	/// Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
	fn vinsertps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Load unaligned packed integer values from mem to xmm1.
	fn vlddqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Load unaligned packed integer values from mem to ymm1.
	fn vlddqu_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Load MXCSR register from m32.
	fn vldmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Selectively write bytes from xmm1 to memory location using the byte mask in xmm2.
	/// The default memory location is specified by DS:DI/EDI/RDI.
	fn vmaskmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Conditionally store packed double-precision values from xmm2 using mask in xmm1.
	fn vmaskmovpd_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister);

	/// Conditionally store packed double-precision values from ymm2 using mask in ymm1.
	fn vmaskmovpd_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM);

	/// Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1.
	fn vmaskmovpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1.
	fn vmaskmovpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Conditionally store packed single-precision values from xmm2 using mask in xmm1.
	fn vmaskmovps_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister);

	/// Conditionally store packed single-precision values from ymm2 using mask in ymm1.
	fn vmaskmovps_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM);

	/// Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1.
	fn vmaskmovps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1.
	fn vmaskmovps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the maximum double-precision floating-point values between xmm2 and xmm3/mem.
	fn vmaxpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the maximum double-precision floating-point values between xmm2 and xmm3/mem.
	fn vmaxpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem.
	fn vmaxpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem.
	fn vmaxpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the maximum single-precision floating-point values between xmm2 and xmm3/mem.
	fn vmaxps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the maximum single-precision floating-point values between xmm2 and xmm3/mem.
	fn vmaxps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem.
	fn vmaxps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem.
	fn vmaxps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2.
	fn vmaxsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2.
	fn vmaxsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2.
	fn vmaxss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2.
	fn vmaxss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the minimum double-precision floating-point values between xmm2 and xmm3/mem.
	fn vminpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the minimum double-precision floating-point values between xmm2 and xmm3/mem.
	fn vminpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem.
	fn vminpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem.
	fn vminpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the minimum single-precision floating-point values between xmm2 and xmm3/mem.
	fn vminps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the minimum single-precision floating-point values between xmm2 and xmm3/mem.
	fn vminps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem.
	fn vminps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem.
	fn vminps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2.
	fn vminsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2.
	fn vminsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2.
	fn vminss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2.
	fn vminss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem.
	fn vmovapd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem.
	fn vmovapd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move aligned packed double-precision floating-point values from xmm2/mem to xmm1.
	fn vmovapd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move aligned packed double-precision floating-point values from xmm2/mem to xmm1.
	fn vmovapd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem.
	fn vmovapd_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed double-precision floating-point values from ymm2/mem to ymm1.
	fn vmovapd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move aligned packed double-precision floating-point values from ymm2/mem to ymm1.
	fn vmovapd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem.
	fn vmovapd_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem.
	fn vmovaps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem.
	fn vmovaps_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move aligned packed single-precision floating-point values from xmm2/mem to xmm1.
	fn vmovaps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move aligned packed single-precision floating-point values from xmm2/mem to xmm1.
	fn vmovaps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem.
	fn vmovaps_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed single-precision floating-point values from ymm2/mem to ymm1.
	fn vmovaps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move aligned packed single-precision floating-point values from ymm2/mem to ymm1.
	fn vmovaps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem.
	fn vmovaps_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Move doubleword from xmm1 register to r/m32.
	fn vmovd_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister);

	/// Move doubleword from xmm1 register to r/m32.
	fn vmovd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Move doubleword from r/m32 to xmm1.
	fn vmovd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Move doubleword from r/m32 to xmm1.
	fn vmovd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit);

	/// Move double-precision floating-point values from xmm2/mem and duplicate into xmm1.
	fn vmovddup_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move double-precision floating-point values from xmm2/mem and duplicate into xmm1.
	fn vmovddup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovddup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovddup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move aligned packed integer values from xmm1 to xmm2/mem.
	fn vmovdqa_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move aligned packed integer values from ymm1 to ymm2/mem.
	fn vmovdqa_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move aligned packed integer values from xmm2/mem to xmm1.
	fn vmovdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move aligned packed integer values from xmm2/mem to xmm1.
	fn vmovdqa_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed integer values from xmm1 to xmm2/mem.
	fn vmovdqa_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move aligned packed integer values from ymm2/mem to ymm1.
	fn vmovdqa_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move aligned packed integer values from ymm2/mem to ymm1.
	fn vmovdqa_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move aligned packed integer values from ymm1 to ymm2/mem.
	fn vmovdqa_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Move unaligned packed integer values from xmm1 to xmm2/mem.
	fn vmovdqu_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move unaligned packed integer values from ymm1 to ymm2/mem.
	fn vmovdqu_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move unaligned packed integer values from xmm2/mem to xmm1.
	fn vmovdqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move unaligned packed integer values from xmm2/mem to xmm1.
	fn vmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed integer values from xmm1 to xmm2/mem.
	fn vmovdqu_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed integer values from ymm2/mem to ymm1.
	fn vmovdqu_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move unaligned packed integer values from ymm2/mem to ymm1.
	fn vmovdqu_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move unaligned packed integer values from ymm1 to ymm2/mem.
	fn vmovdqu_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2.
	fn vmovhlps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Move double-precision floating-point values from high quadword of xmm1 to m64.
	fn vmovhpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Merge double-precision floating-point value from m64 and the low quadword of xmm1.
	fn vmovhpd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Move two packed single-precision floating-point values from high quadword of xmm1to m64.
	fn vmovhps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1.
	fn vmovhps_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2.
	fn vmovlhps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Move double-precision floating-point values from low quadword of xmm1 to m64.
	fn vmovlpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Merge double-precision floating-point value from m64 and the high quadword of xmm1.
	fn vmovlpd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Move two packed single-precision floating-point values from low quadword of xmm1 to m64.
	fn vmovlps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1.
	fn vmovlps_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Extract 2-bit sign mask from xmm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskpd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Extract 4-bit sign mask from ymm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskpd_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM);

	/// Extract 2-bit sign mask from xmm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskpd_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Extract 4-bit sign mask from ymm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskpd_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM);

	/// Extract 4-bit sign mask from xmm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskps_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Extract 8-bit sign mask from ymm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskps_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM);

	/// Extract 4-bit sign mask from xmm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskps_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Extract 8-bit sign mask from ymm2 and store in reg.
	/// The upper bits of r32 or r64 are zeroed.
	fn vmovmskps_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM);

	/// Move packed integer values in xmm1 to m128 using non-temporal hint.
	fn vmovntdq_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed integer values in ymm1 to m256 using non-temporal hint.
	fn vmovntdq_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
	fn vmovntdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type.
	fn vmovntdqa_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move packed double-precision values in xmm1 to m128 using non-temporal hint.
	fn vmovntpd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed double-precision values in ymm1 to m256 using non-temporal hint.
	fn vmovntpd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move packed single-precision values xmm1 to mem using non-temporal hint.
	fn vmovntps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move packed single-precision values ymm1 to mem using non-temporal hint.
	fn vmovntps_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move quadword from xmm1 register to r/m64.
	fn vmovq_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move quadword from xmm2 register to xmm1/m64.
	fn vmovq_Any64BitMemory_XMMRegister_1(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Move quadword from xmm1 register to r/m64.
	fn vmovq_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Move quadword from r/m64 to xmm1.
	fn vmovq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Load quadword from m64 to xmm1.
	fn vmovq_XMMRegister_Any64BitMemory_1(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Move quadword from r/m64 to xmm1.
	fn vmovq_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit);

	/// Move quadword from xmm2 to xmm1.
	fn vmovq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move quadword from xmm2 register to xmm1/m64.
	fn vmovq_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move scalar double-precision floating-point value from xmm1 register to m64.
	fn vmovsd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister);

	/// Load scalar double-precision floating-point value from m64 to xmm1 register.
	fn vmovsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register.
	fn vmovsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1.
	fn vmovsd_XMMRegister_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg3: XMMRegister);

	/// Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
	fn vmovshdup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
	fn vmovshdup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovshdup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovshdup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
	fn vmovsldup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.
	fn vmovsldup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovsldup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.
	fn vmovsldup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move scalar single-precision floating-point value from xmm1 register to m32.
	fn vmovss_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister);

	/// Load scalar single-precision floating-point value from m32 to xmm1 register.
	fn vmovss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.
	fn vmovss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.
	fn vmovss_XMMRegister_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg3: XMMRegister);

	/// Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem.
	fn vmovupd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem.
	fn vmovupd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move unaligned packed double-precision floating-point from xmm2/mem to xmm1.
	fn vmovupd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move unaligned packed double-precision floating-point from xmm2/mem to xmm1.
	fn vmovupd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem.
	fn vmovupd_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed double-precision floating-point from ymm2/mem to ymm1.
	fn vmovupd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move unaligned packed double-precision floating-point from ymm2/mem to ymm1.
	fn vmovupd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem.
	fn vmovupd_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem.
	fn vmovups_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister);

	/// Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem.
	fn vmovups_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM);

	/// Move unaligned packed single-precision floating-point from xmm2/mem to xmm1.
	fn vmovups_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Move unaligned packed single-precision floating-point from xmm2/mem to xmm1.
	fn vmovups_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem.
	fn vmovups_XMMRegister_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Move unaligned packed single-precision floating-point from ymm2/mem to ymm1.
	fn vmovups_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Move unaligned packed single-precision floating-point from ymm2/mem to ymm1.
	fn vmovups_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem.
	fn vmovups_YMM_YMM_1(&mut self, arg0: YMM, arg1: YMM);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1.
	/// Starting offsets within xmm2 and xmm3/m128 are determined by imm8.
	fn vmpsadbw_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1.
	/// Starting offsets within xmm2 and xmm3/m128 are determined by imm8.
	fn vmpsadbw_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1.
	/// Starting offsets within ymm2 and xmm3/m128 are determined by imm8.
	fn vmpsadbw_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1.
	/// Starting offsets within ymm2 and xmm3/m128 are determined by imm8.
	fn vmpsadbw_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vmulpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vmulpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vmulpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vmulpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vmulps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.
	fn vmulps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vmulps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.
	fn vmulps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the low double-precision floating-point value in xmm3/mem64 by low double precision floating-point value in xmm2.
	fn vmulsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Multiply the low double-precision floating-point value in xmm3/mem64 by low double precision floating-point value in xmm2.
	fn vmulsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the low single-precision floating-point value in xmm3/mem by the low single-precision floating-point value in xmm2.
	fn vmulss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Multiply the low single-precision floating-point value in xmm3/mem by the low single-precision floating-point value in xmm2.
	fn vmulss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vorpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vorpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vorpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vorpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vorps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vorps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vorps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vorps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsb_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsb_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.
	fn vpabsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsw_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.
	fn vpabsw_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.
	fn vpackssdw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.
	fn vpackssdw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation.
	fn vpackssdw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation.
	fn vpackssdw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.
	fn vpacksswb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.
	fn vpacksswb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation.
	fn vpacksswb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation.
	fn vpacksswb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
	fn vpackusdw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
	fn vpackusdw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m128 into 16 packed unsigned word integers in ymm1 using unsigned saturation.
	fn vpackusdw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m128 into 16 packed unsigned word integers in ymm1 using unsigned saturation.
	fn vpackusdw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
	fn vpackuswb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
	fn vpackuswb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Converts 16 signed word integers from ymm2 And 16 signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation.
	fn vpackuswb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Converts 16 signed word integers from ymm2 And 16 signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation.
	fn vpackuswb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed byte integers from xmm3/m128 and xmm2.
	fn vpaddb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed byte integers from xmm3/m128 and xmm2.
	fn vpaddb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1.
	fn vpaddb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1.
	fn vpaddb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed doubleword integers from xmm3/m128 and xmm2.
	fn vpaddd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed doubleword integers from xmm3/m128 and xmm2.
	fn vpaddd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed quadword integers xmm3/m128 and xmm2.
	fn vpaddq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed quadword integers xmm3/m128 and xmm2.
	fn vpaddq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.
	fn vpaddsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.
	fn vpaddsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.
	fn vpaddsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.
	fn vpaddsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.
	fn vpaddusb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.
	fn vpaddusb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddusb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddusb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.
	fn vpaddusw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.
	fn vpaddusw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddusw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.
	fn vpaddusw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add packed word integers from xmm3/m128 and xmm2.
	fn vpaddw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add packed word integers from xmm3/m128 and xmm2.
	fn vpaddw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add packed word integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add packed word integers from ymm2, ymm3/m256 and store in ymm1.
	fn vpaddw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.
	fn vpalignr_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.
	fn vpalignr_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.
	fn vpalignr_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.
	fn vpalignr_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Bitwise AND of xmm3/m128 and xmm.
	fn vpand_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Bitwise AND of xmm3/m128 and xmm.
	fn vpand_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1.
	fn vpand_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1.
	fn vpand_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Bitwise AND NOT of xmm3/m128 and xmm2.
	fn vpandn_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Bitwise AND NOT of xmm3/m128 and xmm2.
	fn vpandn_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1.
	fn vpandn_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1.
	fn vpandn_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.
	fn vpavgb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.
	fn vpavgb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1.
	fn vpavgb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1.
	fn vpavgb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.
	fn vpavgw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.
	fn vpavgw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1.
	fn vpavgw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1.
	fn vpavgw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
	fn vpblendd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
	fn vpblendd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
	fn vpblendd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
	fn vpblendd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.
	fn vpblendvb_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister);

	/// Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.
	fn vpblendvb_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister);

	/// Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1.
	fn vpblendvb_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM);

	/// Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1.
	fn vpblendvb_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM);

	/// Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
	fn vpblendw_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.
	fn vpblendw_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
	fn vpblendw_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.
	fn vpblendw_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Broadcast a byte integer in the source operand to sixteen locations in xmm1.
	fn vpbroadcastb_XMMRegister_Any8BitMemory(&mut self, arg0: XMMRegister, arg1: Any8BitMemory);

	/// Broadcast a byte integer in the source operand to sixteen locations in xmm1.
	fn vpbroadcastb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Broadcast a byte integer in the source operand to thirty two locations in ymm1.
	fn vpbroadcastb_YMM_Any8BitMemory(&mut self, arg0: YMM, arg1: Any8BitMemory);

	/// Broadcast a byte integer in the source operand to thirty two locations in ymm1.
	fn vpbroadcastb_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Broadcast a dword integer in the source operand to four locations in xmm1.
	fn vpbroadcastd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Broadcast a dword integer in the source operand to four locations in xmm1.
	fn vpbroadcastd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Broadcast a dword integer in the source operand to eight locations in ymm1.
	fn vpbroadcastd_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory);

	/// Broadcast a dword integer in the source operand to eight locations in ymm1.
	fn vpbroadcastd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Broadcast a qword element in mem to two locations in xmm1.
	fn vpbroadcastq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Broadcast a qword element in mem to two locations in xmm1.
	fn vpbroadcastq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Broadcast a qword element in mem to four locations in ymm1.
	fn vpbroadcastq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Broadcast a qword element in mem to four locations in ymm1.
	fn vpbroadcastq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Broadcast a word integer in the source operand to eight locations in xmm1.
	fn vpbroadcastw_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory);

	/// Broadcast a word integer in the source operand to eight locations in xmm1.
	fn vpbroadcastw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Broadcast a word integer in the source operand to sixteen locations in ymm1.
	fn vpbroadcastw_YMM_Any16BitMemory(&mut self, arg0: YMM, arg1: Any16BitMemory);

	/// Broadcast a word integer in the source operand to sixteen locations in ymm1.
	fn vpbroadcastw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1.
	/// The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.
	fn vpclmulqdq_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1.
	/// The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.
	fn vpclmulqdq_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Compare packed bytes in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed bytes in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed bytes in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed bytes in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed doublewords in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed doublewords in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed doublewords in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed doublewords in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed quadwords in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed quadwords in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed quadwords in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed quadwords in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed words in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed words in xmm3/m128 and xmm2 for equality.
	fn vpcmpeqw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed words in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed words in ymm3/m256 and ymm2 for equality.
	fn vpcmpeqw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
	fn vpcmpestri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
	fn vpcmpestri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.
	fn vpcmpestrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.
	fn vpcmpestrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed qwords in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed qwords in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.
	fn vpcmpgtw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.
	fn vpcmpgtw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
	fn vpcmpistri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
	fn vpcmpistri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.
	fn vpcmpistrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.
	fn vpcmpistrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
	fn vperm2f128_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
	fn vperm2f128_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
	fn vperm2i128_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.
	fn vperm2i128_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Permute doublewords in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
	fn vpermd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Permute doublewords in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
	fn vpermd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Permute double-precision floating-point values in xmm2/mem using controls from imm8.
	fn vpermilpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Permute double-precision floating-point values in xmm2/mem using controls from imm8.
	fn vpermilpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
	fn vpermilpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
	fn vpermilpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Permute double-precision floating-point values in ymm2/mem using controls from imm8.
	fn vpermilpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Permute double-precision floating-point values in ymm2/mem using controls from imm8.
	fn vpermilpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
	fn vpermilpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
	fn vpermilpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1.
	fn vpermilps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1.
	fn vpermilps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
	fn vpermilps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.
	fn vpermilps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1.
	fn vpermilps_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1.
	fn vpermilps_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
	fn vpermilps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.
	fn vpermilps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Permute double-precision floating-point elements in ymm2/m256 using indexes in imm8 and store the result in ymm1.
	fn vpermpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Permute double-precision floating-point elements in ymm2/m256 using indexes in imm8 and store the result in ymm1.
	fn vpermpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Permute single-precision floating-point elements in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
	fn vpermps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Permute single-precision floating-point elements in ymm3/m256 using indexes in ymm2 and store the result in ymm1.
	fn vpermps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Permute qwords in ymm2/m256 using indexes in imm8 and store the result in ymm1.
	fn vpermq_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Permute qwords in ymm2/m256 using indexes in imm8 and store the result in ymm1.
	fn vpermq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8.
	/// The upper bits of r64/r32 is filled with.
	fn vpextrb_Any8BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8.
	/// The upper bits of r64/r32 is filled with.
	fn vpextrb_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8.
	/// The upper bits of r64/r32 is filled with.
	fn vpextrb_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.
	fn vpextrd_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.
	fn vpextrd_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.
	fn vpextrq_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.
	fn vpextrq_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16.
	/// The upper bits of r64/r32 is filled with zeros.
	fn vpextrw_Any16BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0.
	/// Zero-extend the result.
	/// The upper bits of r64/r32 is filled with zeros.
	fn vpextrw_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16.
	/// The upper bits of r64/r32 is filled with zeros.
	fn vpextrw_Register32Bit_XMMRegister_Immediate8Bit_1(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg3: Immediate8Bit);

	/// Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0.
	/// Zero-extend the result.
	/// The upper bits of r64/r32 is filled with zeros.
	fn vpextrw_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16.
	/// The upper bits of r64/r32 is filled with zeros.
	fn vpextrw_Register64Bit_XMMRegister_Immediate8Bit_1(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg3: Immediate8Bit);

	/// Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vpgatherdd_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister);

	/// Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vpgatherdd_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM);

	/// Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vpgatherdq_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister);

	/// Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vpgatherdq_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM);

	/// Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vpgatherqd_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister);

	/// Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vpgatherqd_XMMRegister_Any64BitMemory_XMMRegister_1(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg3: XMMRegister);

	/// Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2.
	/// Conditionally gathered elements are merged into xmm1.
	fn vpgatherqq_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister);

	/// Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2.
	/// Conditionally gathered elements are merged into ymm1.
	fn vpgatherqq_YMM_Any64BitMemory_YMM(&mut self, arg0: YMM, arg1: Any64BitMemory, arg2: YMM);

	/// Add 32-bit integers horizontally, pack to xmm1.
	fn vphaddd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add 32-bit integers horizontally, pack to xmm1.
	fn vphaddd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add 32-bit signed integers horizontally, pack to ymm1.
	fn vphaddd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add 32-bit signed integers horizontally, pack to ymm1.
	fn vphaddd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add 16-bit signed integers horizontally, pack saturated integers to xmm1.
	fn vphaddsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add 16-bit signed integers horizontally, pack saturated integers to xmm1.
	fn vphaddsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add 16-bit signed integers horizontally, pack saturated integers to ymm1.
	fn vphaddsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add 16-bit signed integers horizontally, pack saturated integers to ymm1.
	fn vphaddsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Add 16-bit integers horizontally, pack to xmm1.
	fn vphaddw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Add 16-bit integers horizontally, pack to xmm1.
	fn vphaddw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Add 16-bit signed integers horizontally, pack to ymm1.
	fn vphaddw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Add 16-bit signed integers horizontally, pack to ymm1.
	fn vphaddw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
	fn vphminposuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
	fn vphminposuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Subtract 32-bit signed integers horizontally, pack to xmm1.
	fn vphsubd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract 32-bit signed integers horizontally, pack to xmm1.
	fn vphsubd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract 32-bit signed integers horizontally, pack to ymm1.
	fn vphsubd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract 32-bit signed integers horizontally, pack to ymm1.
	fn vphsubd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.
	fn vphsubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.
	fn vphsubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1.
	fn vphsubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1.
	fn vphsubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract 16-bit signed integers horizontally, pack to xmm1.
	fn vphsubw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract 16-bit signed integers horizontally, pack to xmm1.
	fn vphsubw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract 16-bit signed integers horizontally, pack to ymm1.
	fn vphsubw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract 16-bit signed integers horizontally, pack to ymm1.
	fn vphsubw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.
	fn vpinsrb_XMMRegister_XMMRegister_Any8BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any8BitMemory, arg3: Immediate8Bit);

	/// Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.
	fn vpinsrb_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit);

	/// Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.
	fn vpinsrd_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit);

	/// Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.
	fn vpinsrd_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit);

	/// Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.
	fn vpinsrq_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit);

	/// Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.
	fn vpinsrq_XMMRegister_XMMRegister_Register64Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit, arg3: Immediate8Bit);

	/// Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8.
	fn vpinsrw_XMMRegister_XMMRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any16BitMemory, arg3: Immediate8Bit);

	/// Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8.
	fn vpinsrw_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.
	fn vpmaddubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.
	fn vpmaddubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1.
	fn vpmaddubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1.
	fn vpmaddubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.
	fn vpmaddwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.
	fn vpmaddwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1.
	fn vpmaddwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1.
	fn vpmaddwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Conditionally store dword values from xmm2 using mask in xmm1.
	fn vpmaskmovd_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister);

	/// Conditionally store dword values from ymm2 using mask in ymm1.
	fn vpmaskmovd_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM);

	/// Conditionally load dword values from m128 using mask in xmm2 and store in xmm1.
	fn vpmaskmovd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Conditionally load dword values from m256 using mask in ymm2 and store in ymm1.
	fn vpmaskmovd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Conditionally store qword values from xmm2 using mask in xmm1.
	fn vpmaskmovq_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister);

	/// Conditionally store qword values from ymm2 using mask in ymm1.
	fn vpmaskmovq_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM);

	/// Conditionally load qword values from m128 using mask in xmm2 and store in xmm1.
	fn vpmaskmovq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Conditionally load qword values from m256 using mask in ymm2 and store in ymm1.
	fn vpmaskmovq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed byte integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
	fn vpmaxsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed byte integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
	fn vpmaxsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxsd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
	fn vpmaxsd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.
	fn vpmaxsd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.
	fn vpmaxsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.
	fn vpmaxsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed word integers in ymm3/m128 and ymm2 and store packed maximum values in ymm1.
	fn vpmaxsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed word integers in ymm3/m128 and ymm2 and store packed maximum values in ymm1.
	fn vpmaxsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxub_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxub_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
	fn vpmaxub_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
	fn vpmaxub_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxud_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.
	fn vpmaxud_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
	fn vpmaxud_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.
	fn vpmaxud_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.
	fn vpmaxuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.
	fn vpmaxuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1.
	fn vpmaxuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1.
	fn vpmaxuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminsd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1.
	fn vpminsd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1.
	fn vpminsd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
	fn vpminsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
	fn vpminsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminub_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminub_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminub_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminub_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminud_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.
	fn vpminud_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminud_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.
	fn vpminud_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
	fn vpminuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.
	fn vpminuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.
	fn vpminuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.
	fn vpminuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Move a byte mask of xmm1 to reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn vpmovmskb_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister);

	/// Move a 32-bit mask of ymm1 to reg.
	/// The upper bits of r64 are filled with zeros.
	fn vpmovmskb_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM);

	/// Move a byte mask of xmm1 to reg.
	/// The upper bits of r32 or r64 are filled with zeros.
	fn vpmovmskb_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister);

	/// Move a 32-bit mask of ymm1 to reg.
	/// The upper bits of r64 are filled with zeros.
	fn vpmovmskb_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM);

	/// Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn vpmovsxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn vpmovsxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
	fn vpmovsxbd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
	fn vpmovsxbd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory);

	/// Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxbq_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory);

	/// Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxbq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn vpmovsxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn vpmovsxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.
	fn vpmovsxbw_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.
	fn vpmovsxbw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxdq_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxdq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn vpmovsxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn vpmovsxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.
	fn vpmovsxwd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.
	fn vpmovsxwd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn vpmovsxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxwq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1.
	fn vpmovsxwq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn vpmovzxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
	fn vpmovzxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
	fn vpmovzxbd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.
	fn vpmovzxbd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory);

	/// Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
	fn vpmovzxbq_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory);

	/// Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.
	fn vpmovzxbq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn vpmovzxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
	fn vpmovzxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 16-bit integers in ymm1.
	fn vpmovzxbw_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Zero extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 16-bit integers in ymm1.
	fn vpmovzxbw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
	fn vpmovzxdq_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Zero extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1.
	fn vpmovzxdq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn vpmovzxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
	fn vpmovzxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.
	fn vpmovzxwd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory);

	/// Zero extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1.
	fn vpmovzxwd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
	fn vpmovzxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1.
	fn vpmovzxwq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory);

	/// Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1.
	fn vpmovzxwq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister);

	/// Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.
	fn vpmuldq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.
	fn vpmuldq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1.
	fn vpmuldq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1.
	fn vpmuldq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.
	fn vpmulhrsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.
	fn vpmulhrsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1.
	fn vpmulhrsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1.
	fn vpmulhrsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
	fn vpmulhuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
	fn vpmulhuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
	fn vpmulhuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
	fn vpmulhuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
	fn vpmulhw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.
	fn vpmulhw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
	fn vpmulhw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.
	fn vpmulhw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
	fn vpmulld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
	fn vpmulld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1.
	fn vpmulld_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1.
	fn vpmulld_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
	fn vpmullw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.
	fn vpmullw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1.
	fn vpmullw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1.
	fn vpmullw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.
	fn vpmuludq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.
	fn vpmuludq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1.
	fn vpmuludq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1.
	fn vpmuludq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Bitwise OR of xmm2/m128 and xmm3.
	fn vpor_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Bitwise OR of xmm2/m128 and xmm3.
	fn vpor_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Bitwise OR of ymm2/m256 and ymm3.
	fn vpor_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Bitwise OR of ymm2/m256 and ymm3.
	fn vpor_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
	fn vpsadbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
	fn vpsadbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.
	fn vpsadbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.
	fn vpsadbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shuffle bytes in xmm2 according to contents of xmm3/m128.
	fn vpshufb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shuffle bytes in xmm2 according to contents of xmm3/m128.
	fn vpshufb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shuffle bytes in ymm2 according to contents of ymm3/m256.
	fn vpshufb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shuffle bytes in ymm2 according to contents of ymm3/m256.
	fn vpshufb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshufd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshufd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshufd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshufd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshufhw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshufhw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshufhw_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshufhw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshuflw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
	fn vpshuflw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshuflw_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.
	fn vpshuflw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.
	fn vpsignw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift doublewords in xmm2 left by imm8 while shifting in 0s.
	fn vpslld_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpslld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpslld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift doublewords in ymm2 left by imm8 while shifting in 0s.
	fn vpslld_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpslld_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpslld_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.
	fn vpslldq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1.
	fn vpslldq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift quadwords in xmm2 left by imm8 while shifting in 0s.
	fn vpsllq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift quadwords in ymm2 left by imm8 while shifting in 0s.
	fn vpsllq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllq_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllq_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift bits in doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsllvd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift bits in doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsllvd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift bits in doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsllvd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shift bits in doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsllvd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shift bits in quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsllvq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift bits in quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsllvq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift bits in quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsllvq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shift bits in quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsllvq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shift words in xmm2 left by imm8 while shifting in 0s.
	fn vpsllw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift words in ymm2 left by imm8 while shifting in 0s.
	fn vpsllw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsllw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift doublewords in xmm2 right by imm8 while shifting in sign bits.
	fn vpsrad_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsrad_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsrad_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift doublewords in ymm2 right by imm8 while shifting in sign bits.
	fn vpsrad_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsrad_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsrad_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in the sign bits.
	fn vpsravd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in the sign bits.
	fn vpsravd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in the sign bits.
	fn vpsravd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in the sign bits.
	fn vpsravd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shift words in xmm2 right by imm8 while shifting in sign bits.
	fn vpsraw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsraw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsraw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift words in ymm2 right by imm8 while shifting in sign bits.
	fn vpsraw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsraw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.
	fn vpsraw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift doublewords in xmm2 right by imm8 while shifting in 0s.
	fn vpsrld_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift doublewords in ymm2 right by imm8 while shifting in 0s.
	fn vpsrld_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrld_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrld_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift xmm2 right by imm8 bytes while shifting in 0s.
	fn vpsrldq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift ymm1 right by imm8 bytes while shifting in 0s.
	fn vpsrldq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift quadwords in xmm2 right by imm8 while shifting in 0s.
	fn vpsrlq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift quadwords in ymm2 right by imm8 while shifting in 0s.
	fn vpsrlq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlq_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlq_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsrlvd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsrlvd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsrlvd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsrlvd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shift bits in quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsrlvq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift bits in quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.
	fn vpsrlvq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift bits in quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsrlvq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Shift bits in quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.
	fn vpsrlvq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Shift words in xmm2 right by imm8 while shifting in 0s.
	fn vpsrlw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shift words in ymm2 right by imm8 while shifting in 0s.
	fn vpsrlw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory);

	/// Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.
	fn vpsrlw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister);

	/// Subtract packed byte integers in xmm3/m128 from xmm2.
	fn vpsubb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed byte integers in xmm3/m128 from xmm2.
	fn vpsubb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed byte integers in ymm3/m256 from ymm2.
	fn vpsubb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed byte integers in ymm3/m256 from ymm2.
	fn vpsubb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed doubleword integers in xmm3/m128 from xmm2.
	fn vpsubd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed doubleword integers in xmm3/m128 from xmm2.
	fn vpsubd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed doubleword integers in ymm3/m256 from ymm2.
	fn vpsubd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed doubleword integers in ymm3/m256 from ymm2.
	fn vpsubd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed quadword integers in xmm3/m128 from xmm2.
	fn vpsubq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed quadword integers in xmm3/m128 from xmm2.
	fn vpsubq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed quadword integers in ymm3/m256 from ymm2.
	fn vpsubq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed quadword integers in ymm3/m256 from ymm2.
	fn vpsubq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.
	fn vpsubsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.
	fn vpsubsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results.
	fn vpsubsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results.
	fn vpsubsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.
	fn vpsubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.
	fn vpsubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results.
	fn vpsubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results.
	fn vpsubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.
	fn vpsubusb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.
	fn vpsubusb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result.
	fn vpsubusb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result.
	fn vpsubusb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.
	fn vpsubusw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.
	fn vpsubusw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result.
	fn vpsubusw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result.
	fn vpsubusw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed word integers in xmm3/m128 from xmm2.
	fn vpsubw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed word integers in xmm3/m128 from xmm2.
	fn vpsubw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed word integers in ymm3/m256 from ymm2.
	fn vpsubw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed word integers in ymm3/m256 from ymm2.
	fn vpsubw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Set ZF and CF depending on bitwise AND and ANDN of sources.
	fn vptest_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Set ZF and CF depending on bitwise AND and ANDN of sources.
	fn vptest_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Set ZF and CF depending on bitwise AND and ANDN of sources.
	fn vptest_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Set ZF and CF depending on bitwise AND and ANDN of sources.
	fn vptest_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.
	fn vpunpckhqdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.
	fn vpunpckhqdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhqdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhqdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave high-order words from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave high-order words from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckhwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckhwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.
	fn vpunpcklbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.
	fn vpunpcklbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckldq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.
	fn vpunpckldq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckldq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpckldq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.
	fn vpunpcklqdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.
	fn vpunpcklqdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklqdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklqdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Interleave low-order words from xmm2 and xmm3/m128 into xmm1.
	fn vpunpcklwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Interleave low-order words from xmm2 and xmm3/m128 into xmm1.
	fn vpunpcklwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register.
	fn vpunpcklwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Bitwise XOR of xmm3/m128 and xmm2.
	fn vpxor_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Bitwise XOR of xmm3/m128 and xmm2.
	fn vpxor_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Bitwise XOR of ymm3/m256 and ymm2.
	fn vpxor_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Bitwise XOR of ymm3/m256 and ymm2.
	fn vpxor_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1.
	fn vrcpps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1.
	fn vrcpps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1.
	fn vrcpps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1.
	fn vrcpps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vrcpss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vrcpss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn vroundpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn vroundpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1.
	/// The rounding mode is determined by imm8.
	fn vroundpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1.
	/// The rounding mode is determined by imm8.
	fn vroundpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn vroundps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit);

	/// Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	fn vroundps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit);

	/// Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1.
	/// The rounding mode is determined by imm8.
	fn vroundps_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit);

	/// Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1.
	/// The rounding mode is determined by imm8.
	fn vroundps_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit);

	/// Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	/// Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
	fn vroundsd_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit);

	/// Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	/// Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
	fn vroundsd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	/// Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vroundss_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit);

	/// Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1.
	/// The rounding mode is determined by imm8.
	/// Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vroundss_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1.
	fn vrsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1.
	fn vrsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1.
	fn vrsqrtps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1.
	fn vrsqrtps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vrsqrtss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vrsqrtss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Shuffle Packed double-precision floating- point values selected by imm8 from xmm2 and xmm3/mem.
	fn vshufpd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Shuffle Packed double-precision floating- point values selected by imm8 from xmm2 and xmm3/mem.
	fn vshufpd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Shuffle Packed double-precision floating- point values selected by imm8 from ymm2 and ymm3/mem.
	fn vshufpd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Shuffle Packed double-precision floating- point values selected by imm8 from ymm2 and ymm3/mem.
	fn vshufpd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.
	fn vshufps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit);

	/// Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.
	fn vshufps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit);

	/// Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.
	fn vshufps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit);

	/// Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.
	fn vshufps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit);

	/// Computes Square Roots of the packed double- precision floating-point values in xmm2/m128 and stores the result in xmm1.
	fn vsqrtpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes Square Roots of the packed double- precision floating-point values in xmm2/m128 and stores the result in xmm1.
	fn vsqrtpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes Square Roots of the packed double- precision floating-point values in ymm2/m256 and stores the result in ymm1.
	fn vsqrtpd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Computes Square Roots of the packed double- precision floating-point values in ymm2/m256 and stores the result in ymm1.
	fn vsqrtpd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Computes Square Roots of the packed single- precision floating-point values in xmm2/m128 and stores the result in xmm1.
	fn vsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Computes Square Roots of the packed single- precision floating-point values in xmm2/m128 and stores the result in xmm1.
	fn vsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Computes Square Roots of the packed single- precision floating-point values in ymm2/m256 and stores the result in ymm1.
	fn vsqrtps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Computes Square Roots of the packed single- precision floating-point values in ymm2/m256 and stores the result in ymm1.
	fn vsqrtps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Computes square root of the low double- precision floating point value in xmm3/m64 and stores the results in xmm2.
	/// Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
	fn vsqrtsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Computes square root of the low double- precision floating point value in xmm3/m64 and stores the results in xmm2.
	/// Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].
	fn vsqrtsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Computes square root of the low single- precision floating-point value in xmm3/m32 and stores the results in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vsqrtss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Computes square root of the low single- precision floating-point value in xmm3/m32 and stores the results in xmm1.
	/// Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].
	fn vsqrtss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Store contents of MXCSR register to m32.
	fn vstmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Subtract packed double-precision floating- point values in xmm3/mem from xmm2 and stores result in xmm1.
	fn vsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed double-precision floating- point values in xmm3/mem from xmm2 and stores result in xmm1.
	fn vsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed double-precision floating- point values in ymm3/mem from ymm2 and stores result in ymm1.
	fn vsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed double-precision floating- point values in ymm3/mem from ymm2 and stores result in ymm1.
	fn vsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.
	fn vsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.
	fn vsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.
	fn vsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.
	fn vsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Subtract the low double-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
	fn vsubsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory);

	/// Subtract the low double-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
	fn vsubsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Subtract the low single-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
	fn vsubss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory);

	/// Subtract the low single-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1.
	fn vsubss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
	fn vtestpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
	fn vtestpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
	fn vtestpd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources.
	fn vtestpd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
	fn vtestps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
	fn vtestps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
	fn vtestps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory);

	/// Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources.
	fn vtestps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM);

	/// Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn vucomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory);

	/// Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
	fn vucomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn vucomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory);

	/// Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
	fn vucomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.
	fn vunpckhpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.
	fn vunpckhpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.
	fn vunpckhpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.
	fn vunpckhpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128.
	fn vunpckhps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128.
	fn vunpckhps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256.
	fn vunpckhps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256.
	fn vunpckhps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128.
	fn vunpcklpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128.
	fn vunpcklpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256.
	fn vunpcklpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256.
	fn vunpcklpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128.
	fn vunpcklps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128.
	fn vunpcklps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256.
	fn vunpcklps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256.
	fn vunpcklps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vxorpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem.
	fn vxorpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vxorpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem.
	fn vxorpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vxorps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory);

	/// Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem.
	fn vxorps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister);

	/// Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vxorps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory);

	/// Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem.
	fn vxorps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM);

	/// Zero all YMM registers.
	fn vzeroall(&mut self);

	/// Zero upper 128 bits of all YMM registers.
	fn vzeroupper(&mut self);

	/// Check pending unmasked floating-point exceptions.
	fn wait(&mut self);

	/// Load the FS base address with the 32-bit value in the source register.
	fn wrfsbase_Register32Bit(&mut self, arg0: Register32Bit);

	/// Load the FS base address with the 64-bit value in the source register.
	fn wrfsbase_Register64Bit(&mut self, arg0: Register64Bit);

	/// Load the GS base address with the 32-bit value in the source register.
	fn wrgsbase_Register32Bit(&mut self, arg0: Register32Bit);

	/// Load the GS base address with the 64-bit value in the source register.
	fn wrgsbase_Register64Bit(&mut self, arg0: Register64Bit);

	/// Causes an RTM abort if in RTM execution.
	fn xabort_Immediate8Bit(&mut self, arg0: Immediate8Bit);

	/// A hint used with an "XACQUIRE-enabled" instruction to start lock elision on the instruction memory operand address.
	fn xacquire(&mut self);

	/// Exchange r16 and r/m16; load sum into r/m16.
	fn xadd_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Exchange r32 and r/m32; load sum into r/m32.
	fn xadd_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Exchange r64 and r/m64; load sum into r/m64.
	fn xadd_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange r16 and r/m16; load sum into r/m16.
	fn xadd_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Exchange r32 and r/m32; load sum into r/m32.
	fn xadd_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Exchange r64 and r/m64; load sum into r/m64.
	fn xadd_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Exchange r8 and r/m8; load sum into r/m8.
	fn xadd_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Specifies the start of an RTM region.
	/// Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
	fn xbegin_Label(&mut self, arg0: Label);

	/// Specifies the start of an RTM region.
	/// Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.
	fn xbegin_Relative32Bit(&mut self, arg0: Relative32Bit);

	/// Exchange r16 with AX.
	fn xchg_AX_Register16Bit(&mut self, arg0: AX, arg1: Register16Bit);

	/// Exchange r32 with EAX.
	fn xchg_EAX_Register32Bit(&mut self, arg0: EAX, arg1: Register32Bit);

	/// Exchange r16 with word from r/m16.
	fn xchg_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// Exchange r32 with doubleword from r/m32.
	fn xchg_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// Exchange r64 with quadword from r/m64.
	fn xchg_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange AX with r16.
	fn xchg_Register16Bit_AX(&mut self, arg0: Register16Bit, arg1: AX);

	/// Exchange word from r/m16 with r16.
	fn xchg_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// Exchange r16 with word from r/m16.
	fn xchg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Exchange word from r/m16 with r16.
	fn xchg_Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// Exchange EAX with r32.
	fn xchg_Register32Bit_EAX(&mut self, arg0: Register32Bit, arg1: EAX);

	/// Exchange doubleword from r/m32 with r32.
	fn xchg_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// Exchange r32 with doubleword from r/m32.
	fn xchg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Exchange doubleword from r/m32 with r32.
	fn xchg_Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// Exchange quadword from r/m64 with r64.
	fn xchg_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// Exchange r64 with quadword from r/m64.
	fn xchg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Exchange quadword from r/m64 with r64.
	fn xchg_Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// Exchange RAX with r64.
	fn xchg_Register64Bit_RAX(&mut self, arg0: Register64Bit, arg1: RAX);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange r64 with `RAX`.
	fn xchg_RAX_Register64Bit(&mut self, arg0: RAX, arg1: Register64Bit);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// Exchange r8 (byte register) with byte from r/m8.
	fn xchg_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Exchange byte from r/m8 with r8 (byte register).
	fn xchg_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Specifies the end of an RTM code region.
	fn xend(&mut self);

	/// Reads an XCR specified by `ECX` into `EDX:EAX`.
	fn xgetbv(&mut self);

	/// Set `AL` to memory byte `DS:[(E)BX + unsigned AL]`.
	fn xlat_Any8BitMemory(&mut self, arg0: Any8BitMemory);

	/// Set `AL` to memory byte `DS:[(E)BX + unsigned AL]`.
	fn xlatb(&mut self);

	/// Set `AL` to memory byte [RBX + unsigned AL].
	fn xlatb_1(&mut self);

	/// AL XOR imm8.
	fn xor_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit);

	/// AX XOR imm16.
	fn xor_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit);

	/// EAX XOR imm32.
	fn xor_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit);

	/// r/m16 XOR imm16.
	fn xor_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit);

	/// r/m16 XOR imm8 (sign-extended).
	fn xor_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit);

	/// r/m16 XOR r16.
	fn xor_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit);

	/// r/m32 XOR imm32.
	fn xor_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit);

	/// r/m32 XOR imm8 (sign-extended).
	fn xor_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit);

	/// r/m32 XOR r32.
	fn xor_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit);

	/// r/m64 XOR imm32 (sign-extended).
	fn xor_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit);

	/// r/m64 XOR imm8 (sign-extended).
	fn xor_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit);

	/// r/m64 XOR r64.
	fn xor_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit);

	/// r/m8 XOR imm8.
	fn xor_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit);

	/// r/m8 XOR r8.
	fn xor_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit);

	/// r/m8 XOR r8.
	fn xor_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit);

	/// r/m16 XOR imm16.
	fn xor_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit);

	/// r/m16 XOR imm8 (sign-extended).
	fn xor_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit);

	/// r16 XOR r/m16.
	fn xor_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory);

	/// r/m16 XOR r16.
	fn xor_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r16 XOR r/m16.
	fn xor__Register16Bit_Register16Bit_1(&mut self, arg0: Register16Bit, arg1: Register16Bit);

	/// r/m32 XOR imm32.
	fn xor_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit);

	/// r/m32 XOR imm8 (sign-extended).
	fn xor_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit);

	/// r32 XOR r/m32.
	fn xor_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory);

	/// r/m32 XOR r32.
	fn xor_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r32 XOR r/m32.
	fn xor__Register32Bit_Register32Bit_1(&mut self, arg0: Register32Bit, arg1: Register32Bit);

	/// r/m64 XOR imm32 (sign-extended).
	fn xor_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit);

	/// r/m64 XOR imm8 (sign-extended).
	fn xor_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit);

	/// r64 XOR r/m64.
	fn xor_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory);

	/// r/m64 XOR r64.
	fn xor_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r64 XOR r/m64.
	fn xor__Register64Bit_Register64Bit_1(&mut self, arg0: Register64Bit, arg1: Register64Bit);

	/// r/m8 XOR imm8.
	fn xor_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit);

	/// r8 XOR r/m8.
	fn xor_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory);

	/// r/m8 XOR r8.
	fn xor_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r8 XOR r/m8.
	fn xor__Register8Bit_Register8Bit_1(&mut self, arg0: Register8Bit, arg1: Register8Bit);

	/// r/m8 XOR r8.
	fn xor_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 XOR r/m8.
	fn xor__Register8Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// RAX XOR imm32 (sign-extended).
	fn xor_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit);

	/// r/m8 XOR imm8.
	fn xor_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit);

	/// r8 XOR r/m8.
	fn xor_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory);

	/// r/m8 XOR r8.
	fn xor_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r8 XOR r/m8.
	fn xor__RegisterHigh8BitsOf16Bit_Register8Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit);

	/// r/m8 XOR r8.
	fn xor_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// r8 XOR r/m8.
	fn xor__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit_1(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit);

	/// Bitwise exclusive-OR of xmm2/m128 and xmm1.
	fn xorpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise exclusive-OR of xmm2/m128 and xmm1.
	fn xorpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// Bitwise exclusive-OR of xmm2/m128 and xmm1.
	fn xorps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory);

	/// Bitwise exclusive-OR of xmm2/m128 and xmm1.
	fn xorps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister);

	/// A hint used with an "XRELEASE-enabled" instruction to end lock elision on the instruction memory operand address.
	fn xrelease(&mut self);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor64_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor64_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Restore processor extended states from memory.
	/// The states are specified by `EDX:EAX`.
	fn xrstor64_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave64_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave64_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Save processor extended states to memory.
	/// The states are specified by `EDX:EAX`.
	fn xsave64_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt64_Any16BitMemory(&mut self, arg0: Any16BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt64_Any32BitMemory(&mut self, arg0: Any32BitMemory);

	/// Save processor extended states specified in `EDX:EAX` to memory, optimizing the state save operation if possible.
	fn xsaveopt64_Any64BitMemory(&mut self, arg0: Any64BitMemory);

	/// Test if executing in a transactional region.
	fn xtest(&mut self);
}

impl OrdinaryInstructionStream
{
	#[inline(always)]
	fn adc_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x14);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x15);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x15);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x15);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn adc_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x04);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x05);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x05);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x05);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn add_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsubpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsubpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsubps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn addsubps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesdec_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesdec_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesdeclast_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesdeclast_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesenc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesenc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesenclast_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesenclast_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesimc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aesimc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aeskeygenassist_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn aeskeygenassist_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x24);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x25);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x25);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x25);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn and__1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andn_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn andn_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn andn_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn andn_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn andnpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x55);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andnpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x55);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andnps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x55);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andnps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x55);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x54);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x54);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x54);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn andps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x54);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bextr_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bextr_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bextr_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bextr_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blendpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0D);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0D);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0C);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0C);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendvpd_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendvpd_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendvps_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blendvps_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn blsi_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsi_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsi_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsi_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsmsk_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsmsk_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsmsk_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsmsk_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsr_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_1);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg0, arg1, Self::R64S_1);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsr_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_1);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn blsr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg0, arg1, Self::R64S_1);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg1, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bsf_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsf_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsf_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsf_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsf_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsf_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bsr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bswap_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bswap_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xC8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xBB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn btr_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xB3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bts_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAB);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn bzhi_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bzhi_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bzhi_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn bzhi_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x0, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn call_FarPointer16BitTo16Bit(&mut self, arg0: FarPointer16BitTo16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn call_FarPointer16BitTo32Bit(&mut self, arg0: FarPointer16BitTo32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn call_FarPointer16BitTo64Bit(&mut self, arg0: FarPointer16BitTo64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn call_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn call_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn call_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn call_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cbw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x98);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cdq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x99);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cdqe(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x98);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn clc(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cld(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn clflush_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cli(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmc(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xF5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmova_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovae_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovbe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmove_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovge_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovl_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovle_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovna_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x46);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnae_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnbe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x47);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnc_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x43);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovne_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovng_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnge_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnl_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnle_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovno_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovns_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x49);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovnz_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x45);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovo_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpe_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovpo_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x4B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovs_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x48);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmovz_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x3C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x3D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x3D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x3D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmp_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmppd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmppd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmps_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsd_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpss_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpss_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC2);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpsw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xB1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xB0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg16b_Any128BitMemory(&mut self, arg0: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cmpxchg8b_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn comisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn comisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn comiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn comiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cpuid(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA2);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cqo(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x99);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn crc32_Register64Bit_Register8Bit(&mut self, arg0: Register64Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtdq2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtdq2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtdq2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtdq2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2pi_MmRegister_Any128BitMemory(&mut self, arg0: MmRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpd2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpi2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpi2pd_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpi2ps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtpi2ps_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2pi_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtps2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2ss_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsd2ss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2sd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2sd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2sd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2sd_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2ss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2ss_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2ss_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtsi2ss_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2sd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2sd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvtss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttpd2pi_MmRegister_Any128BitMemory(&mut self, arg0: MmRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttpd2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttps2pi_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttps2pi_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cvttss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cwd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x99);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn cwde(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x98);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dec_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn div_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn divss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dppd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dppd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dpps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn dpps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn emms(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn enter_Immediate8Bit_Immediate16Bit(&mut self, arg0: Immediate8Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn enter_One_Immediate16Bit(&mut self, arg0: One, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn enter_Zero_Immediate16Bit(&mut self, arg0: Zero, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn extractps_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn extractps_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn extractps_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn f2xm1(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fabs(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fadd_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fadd_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fadd_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xC0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fadd_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xC0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn faddp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xC1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn faddp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xC0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fbld_X87BinaryCodedDecimal80BitMemory(&mut self, arg0: X87BinaryCodedDecimal80BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fbstp_X87BinaryCodedDecimal80BitMemory(&mut self, arg0: X87BinaryCodedDecimal80BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fchs(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fclex(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xE2);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovb_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDA, 0xC0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovbe_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDA, 0xD0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmove_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDA, 0xC8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovnb_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xC0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovnbe_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xD0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovne_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xC8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovnu_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xD8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcmovu_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDA, 0xD8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcom(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xD1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcom_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcom_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcom_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8, 0xD0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomi_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xF0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomip_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDF, 0xF0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xD9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomp_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomp_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcomp_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8, 0xD8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcompp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xD9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fcos(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdecstp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdiv_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdiv_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdiv_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xF0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdiv_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xF0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xF1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xF0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivr_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivr_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivr_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xF8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivr_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xF8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivrp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xF9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fdivrp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xF8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ffree_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD, 0xC0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fiadd_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fiadd_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ficom_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ficom_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ficomp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ficomp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fidiv_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fidiv_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fidivr_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fidivr_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fild_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fild_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fild_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fimul_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fimul_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fincstp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn finit(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fist_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fist_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fistp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fistp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fistp_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisttp_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisttp_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisttp_X87Integer64BitMemory(&mut self, arg0: X87Integer64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisub_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisub_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisubr_X87Integer16BitMemory(&mut self, arg0: X87Integer16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fisubr_X87Integer32BitMemory(&mut self, arg0: X87Integer32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fld_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fld_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fld_X87Float80BitMemory(&mut self, arg0: X87Float80BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fld_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9, 0xC0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fld1(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldl2e(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xEA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldl2t(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldlg2(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xEC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldln2(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xED);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldpi(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xEB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fldz(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xEE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmul_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmul_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmul_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xC8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmul_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xC8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmulp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xC9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fmulp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xC8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnclex(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xE2);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fninit(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnop(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xD0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnsave_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnstcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnstenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnstsw_AX(&mut self, arg0: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDF, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fnstsw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fpatan(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fprem(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fprem1(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fptan(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF2);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn frndint(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn frstor_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsave_Contiguous108ByteMemory(&mut self, arg0: Contiguous108ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fscale(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsin(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsincos(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsqrt(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xFA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fst_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fst_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fst_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD, 0xD0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstcw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstenv_Contiguous28ByteMemory(&mut self, arg0: Contiguous28ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstp_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstp_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstp_X87Float80BitMemory(&mut self, arg0: X87Float80BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstp_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD, 0xD8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstsw_AX(&mut self, arg0: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDF, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fstsw_Contiguous2ByteMemory(&mut self, arg0: Contiguous2ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsub_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsub_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsub_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xE0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsub_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xE0, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xE1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xE0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubr_X87Float32BitMemory(&mut self, arg0: X87Float32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubr_X87Float64BitMemory(&mut self, arg0: X87Float64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubr_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDC, 0xE8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubr_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD8, 0xE8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubrp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fsubrp_X87Register_ST0(&mut self, arg0: X87Register, arg1: ST0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDE, 0xE8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ftst(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucom(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDD, 0xE1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucom_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD, 0xE0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucomi_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDB, 0xE8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucomip_ST0_X87Register(&mut self, arg0: ST0, arg1: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDF, 0xE8, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucomp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDD, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucomp_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xDD, 0xE8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fucompp(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xDA, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fwait(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		// No Opcode Bytes	// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxam(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xE5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxch(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xC9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxch_X87Register(&mut self, arg0: X87Register)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD9, 0xC8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxrstor_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxrstor64_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxsave_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxsave64_Contiguous512ByteMemory(&mut self, arg0: Contiguous512ByteMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fxtract(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fyl2x(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn fyl2xp1(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD9, 0xF9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn haddpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn haddpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn haddps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn haddps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn hsubpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn hsubpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn hsubps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn hsubps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn idiv_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Any16BitMemory_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Any16BitMemory, arg2: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Any16BitMemory_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Any16BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Any32BitMemory_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Any32BitMemory_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Any64BitMemory_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Any64BitMemory_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn imul_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_AL_DX(&mut self, arg0: AL, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE4);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_AX_DX(&mut self, arg0: AX, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xED);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_AX_Immediate8Bit(&mut self, arg0: AX, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE5);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_EAX_DX(&mut self, arg0: EAX, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xED);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn in_EAX_Immediate8Bit(&mut self, arg0: EAX, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE5);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn inc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ins_Any16BitMemory_DX(&mut self, arg0: Any16BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ins_Any32BitMemory_DX(&mut self, arg0: Any32BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ins_Any8BitMemory_DX(&mut self, arg0: Any8BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn insb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn insd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn insertps_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn insertps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn insw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn int__Immediate8Bit(&mut self, arg0: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCD);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn int__Three(&mut self, arg0: Three)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn invpcid_Register64Bit_Any128BitMemory(&mut self, arg0: Register64Bit, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x82);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn iret(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn iretd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn iretq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xCF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ja_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn ja_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn ja_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn ja_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn ja_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ja_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ja_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ja_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jae_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jae_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jae_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jae_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jae_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jae_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jae_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jae_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jb_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jb_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jb_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jb_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jb_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jb_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jb_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jb_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jbe_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jbe_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jbe_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jbe_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jbe_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jbe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jbe_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jbe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jc_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jc_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jc_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jc_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jc_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jc_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jc_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jc_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn je_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn je_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn je_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn je_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn je_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn je_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn je_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn je_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jecxz_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jecxz_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jecxz_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jecxz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jg_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jg_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jg_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jg_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jg_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jg_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jg_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jg_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jge_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jge_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jge_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jge_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jge_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jge_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jge_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jge_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jl_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jl_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jl_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jl_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jl_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jl_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jl_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jl_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jle_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jle_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jle_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jle_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jle_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jle_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jle_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jle_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_FarPointer16BitTo16Bit(&mut self, arg0: FarPointer16BitTo16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_FarPointer16BitTo32Bit(&mut self, arg0: FarPointer16BitTo32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_FarPointer16BitTo64Bit(&mut self, arg0: FarPointer16BitTo64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xFF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jmp_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jmp_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE9);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jmp_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEB);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jna_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jna_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jna_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jna_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jna_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jna_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x86);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jna_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jna_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x76);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnae_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnae_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnae_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnae_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnae_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnae_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x82);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnae_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnae_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x72);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnb_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnb_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnb_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnb_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnb_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnb_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnb_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnb_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnbe_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnbe_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnbe_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnbe_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnbe_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnbe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x87);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnbe_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnbe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnc_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnc_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnc_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnc_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnc_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnc_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x83);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnc_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnc_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x73);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jne_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jne_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jne_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jne_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jne_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jne_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jne_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jne_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jng_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jng_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jng_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jng_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jng_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jng_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jng_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jng_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7E);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnge_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnge_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnge_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnge_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnge_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnge_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnge_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnge_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnl_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnl_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnl_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnl_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnl_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnl_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnl_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnl_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnle_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnle_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnle_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnle_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnle_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnle_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnle_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnle_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7F);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jno_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x71);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jno_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x81);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jno_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x71);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jno_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x81);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jno_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x81);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jno_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x81);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jno_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x71);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jno_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x71);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnp_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnp_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnp_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnp_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnp_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnp_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnp_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnp_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jns_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x79);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jns_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x89);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jns_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x79);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jns_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x89);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jns_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x89);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jns_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x89);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jns_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x79);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jns_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x79);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnz_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnz_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnz_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnz_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jnz_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnz_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x85);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnz_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jnz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x75);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jo_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x70);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jo_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x80);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jo_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x70);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jo_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x80);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jo_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x80);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jo_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x80);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jo_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x70);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jo_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x70);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jp_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jp_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jp_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jp_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jp_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jp_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jp_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jp_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpe_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpe_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpe_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpe_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpe_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpe_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpe_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpe_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpo_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpo_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpo_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpo_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jpo_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpo_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x8B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpo_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jpo_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x7B);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jrcxz_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jrcxz_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jrcxz_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jrcxz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn js_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x78);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn js_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x88);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn js_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x78);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn js_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x88);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn js_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x88);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn js_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x88);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn js_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x78);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn js_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x78);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jz_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jz_1_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jz_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jz_1_Label_Hint(&mut self, arg0: Label, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn jz_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jz_Relative32Bit_Hint(&mut self, arg0: Relative32Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x84);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jz_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn jz_Relative8Bit_Hint(&mut self, arg0: Relative8Bit, arg1: Hint)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x74);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lahf(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lar_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lddqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ldmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register16Bit_Any32BitMemory(&mut self, arg0: Register16Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register16Bit_Any64BitMemory(&mut self, arg0: Register16Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lea_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn leave(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn leave_Prefix66(&mut self, arg0: Prefix66)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lfence(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xAE, 0xE8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lfs_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lfs_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lfs_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lgs_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lgs_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lgs_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lock(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xF0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lods_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lods_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lods_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lods_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lodsb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lodsd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lodsq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lodsw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn loop_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE2);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn loop_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE2);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn loope_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn loope_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn loopne_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label8(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn loopne_Relative8Bit(&mut self, arg0: Relative8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lsl_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lss_Register16Bit_FarPointer16BitTo16Bit(&mut self, arg0: Register16Bit, arg1: FarPointer16BitTo16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lss_Register32Bit_FarPointer16BitTo32Bit(&mut self, arg0: Register32Bit, arg1: FarPointer16BitTo32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lss_Register64Bit_FarPointer16BitTo64Bit(&mut self, arg0: Register64Bit, arg1: FarPointer16BitTo64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn lzcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maskmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maskmovq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn maxss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mfence(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xAE, 0xF0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn minss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn monitor(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xC8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_AL_MemoryOffset8Bit(&mut self, arg0: AL, arg1: MemoryOffset8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_AL_MemoryOffset8Bit_PrefixRexW(&mut self, arg0: AL, arg1: MemoryOffset8Bit, arg2: PrefixRexW)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_AX_MemoryOffset16Bit(&mut self, arg0: AX, arg1: MemoryOffset16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA1);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_EAX_MemoryOffset32Bit(&mut self, arg0: EAX, arg1: MemoryOffset32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA1);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any16BitMemory_Sreg(&mut self, arg0: Any16BitMemory, arg1: Sreg)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any64BitMemory_Sreg(&mut self, arg0: Any64BitMemory, arg1: Sreg)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_MemoryOffset16Bit_AX(&mut self, arg0: MemoryOffset16Bit, arg1: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_MemoryOffset32Bit_EAX(&mut self, arg0: MemoryOffset32Bit, arg1: EAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_MemoryOffset64Bit_RAX(&mut self, arg0: MemoryOffset64Bit, arg1: RAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA3);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_MemoryOffset8Bit_AL(&mut self, arg0: MemoryOffset8Bit, arg1: AL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA2);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_MemoryOffset8Bit_AL_PrefixRexW(&mut self, arg0: MemoryOffset8Bit, arg1: AL, arg2: PrefixRexW)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA2);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xB8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register16Bit_Sreg(&mut self, arg0: Register16Bit, arg1: Sreg)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xB8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register64Bit_Immediate64Bit(&mut self, arg0: Register64Bit, arg1: Immediate64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xB8, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x89);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register64Bit_Sreg(&mut self, arg0: Register64Bit, arg1: Sreg)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xB0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_RAX_MemoryOffset64Bit(&mut self, arg0: RAX, arg1: MemoryOffset64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA1);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xB0, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x88);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Sreg_Any16BitMemory(&mut self, arg0: Sreg, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Sreg_Any64BitMemory(&mut self, arg0: Sreg, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Sreg_Register16Bit(&mut self, arg0: Sreg, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mov_Sreg_Register64Bit(&mut self, arg0: Sreg, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movapd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movapd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movapd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movapd_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movaps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movaps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movaps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movaps_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movbe_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x38, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_Any32BitMemory_MmRegister(&mut self, arg0: Any32BitMemory, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_MmRegister_Register32Bit(&mut self, arg0: MmRegister, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_Register32Bit_MmRegister(&mut self, arg0: Register32Bit, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movddup_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movddup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdq2q_MmRegister_XMMRegister(&mut self, arg0: MmRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqa_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqa_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqa_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqu_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movdqu_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movhlps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movhpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movhpd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movhps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movhps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movlhps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movlpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x13);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movlpd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movlps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x13);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movlps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movmskpd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movmskpd_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movmskps_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movmskps_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movntdq_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xE7);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movntdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movnti_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movnti_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xC3);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movntpd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movntps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movntq_Any64BitMemory_MmRegister(&mut self, arg0: Any64BitMemory, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xE7);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_Any64BitMemory_MmRegister(&mut self, arg0: Any64BitMemory, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_Any64BitMemory_MmRegister(&mut self, arg0: Any64BitMemory, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xD6);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_MmRegister_Register64Bit(&mut self, arg0: MmRegister, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_Register64Bit_MmRegister(&mut self, arg0: Register64Bit, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x7E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xD6);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movq2dq_XMMRegister_MmRegister(&mut self, arg0: XMMRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movs_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movs_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movs_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movs_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsd_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movshdup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movshdup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsldup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsldup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movss_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movss_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register16Bit_Any8BitMemory(&mut self, arg0: Register16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register16Bit_Register8Bit(&mut self, arg0: Register16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register64Bit_Register16Bit(&mut self, arg0: Register64Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsx_Register64Bit_Register8Bit(&mut self, arg0: Register64Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsxd_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movsxd_Register64Bit_Register32Bit(&mut self, arg0: Register64Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movupd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movupd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movupd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movupd_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movups_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movups_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movups_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movups_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register16Bit_Any8BitMemory(&mut self, arg0: Register16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register16Bit_Register8Bit(&mut self, arg0: Register16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register32Bit_Any16BitMemory(&mut self, arg0: Register32Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register32Bit_Any8BitMemory(&mut self, arg0: Register32Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register32Bit_Register16Bit(&mut self, arg0: Register32Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register32Bit_Register8Bit(&mut self, arg0: Register32Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register32Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register32Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register64Bit_Any16BitMemory(&mut self, arg0: Register64Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register64Bit_Any8BitMemory(&mut self, arg0: Register64Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register64Bit_Register16Bit(&mut self, arg0: Register64Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn movzx_Register64Bit_Register8Bit(&mut self, arg0: Register64Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mpsadbw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mpsadbw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x42);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mul_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn mulx_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn mulx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn mulx_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn mulx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn mwait(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xC9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn neg_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn nop(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x90);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn nop_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x1F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn nop_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x1F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn nop_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x1F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn nop_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x1F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn not__RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x0D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn or__1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn orpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x56);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn orpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x56);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn orps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x56);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn orps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x56);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_DX_AL(&mut self, arg0: DX, arg1: AL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_DX_AX(&mut self, arg0: DX, arg1: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_DX_EAX(&mut self, arg0: DX, arg1: EAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xEF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_Immediate8Bit_AL(&mut self, arg0: Immediate8Bit, arg1: AL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE6);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_Immediate8Bit_AX(&mut self, arg0: Immediate8Bit, arg1: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE7);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn out_Immediate8Bit_EAX(&mut self, arg0: Immediate8Bit, arg1: EAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xE7);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outs_DX_Any16BitMemory(&mut self, arg0: DX, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outs_DX_Any32BitMemory(&mut self, arg0: DX, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outs_DX_Any8BitMemory(&mut self, arg0: DX, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outsb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outsd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn outsw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pabsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packssdw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packssdw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packssdw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packssdw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packsswb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packsswb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packsswb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packsswb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packusdw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packusdw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packuswb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x67);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packuswb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x67);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packuswb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x67);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn packuswb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x67);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xED);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xED);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xED);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xED);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddusw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn paddw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFD);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn palignr_MmRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn palignr_MmRegister_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: MmRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn palignr_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn palignr_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pand_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pand_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pand_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pand_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pandn_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pandn_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pandn_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pandn_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pause(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x90);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pavgw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pblendvb_XMMRegister_Any128BitMemory_XMMRegister0(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pblendvb_XMMRegister_XMMRegister_XMMRegister0(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister0)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pblendw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pblendw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pclmulqdq_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pclmulqdq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x44);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x74);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x74);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x74);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x74);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x76);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x76);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x76);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x76);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x29);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x29);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x75);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x75);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x75);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpeqw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x75);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpestri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpestri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpestrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpestrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x64);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x64);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x64);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x64);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x66);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x66);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x66);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x66);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x37);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x37);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x65);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x65);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x65);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpgtw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x65);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpistri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpistri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpistrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pcmpistrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pdep_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pdep_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pdep_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pdep_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pext_Register32Bit_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pext_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pext_Register64Bit_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x2, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pext_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x2, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn pextrb_Any8BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrb_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrb_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrd_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrd_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrq_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x3A, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrq_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0x3A, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_Any16BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_Register32Bit_MmRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: MmRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_1_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_Register64Bit_MmRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: MmRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pextrw_1_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x02);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x03);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phaddw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phminposuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phminposuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x06);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x06);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x06);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x06);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x07);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x07);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x07);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x07);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn phsubw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrb_XMMRegister_Any8BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any8BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrb_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrd_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrd_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrw_MmRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any16BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC4);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrw_MmRegister_Register32Bit_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC4);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrw_XMMRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any16BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC4);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pinsrw_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC4);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddwd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaddwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxub_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxub_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxub_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxub_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDE);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxud_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxud_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmaxuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x38);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x38);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x39);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x39);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminub_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminub_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminub_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminub_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xDA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminud_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminud_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pminuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x3A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovmskb_Register32Bit_MmRegister(&mut self, arg0: Register32Bit, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovmskb_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovmskb_Register64Bit_MmRegister(&mut self, arg0: Register64Bit, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovmskb_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovsxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmovzxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuldq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuldq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhrsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhrsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhrsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhrsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhuw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhuw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulhw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmulld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x40);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmullw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmullw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmullw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmullw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD5);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuludq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuludq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuludq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pmuludq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF4);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_FS(&mut self, arg0: FS)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_FS_Prefix66(&mut self, arg0: FS, arg1: Prefix66)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_GS(&mut self, arg0: GS)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_GS_Prefix66(&mut self, arg0: GS, arg1: Prefix66)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x8F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x8F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x8F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_1_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x58, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x8F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pop_1_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x58, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xB8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popf(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn popfq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn por_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn por_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn por_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn por_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn prefetchnta_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn prefetcht0_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn prefetcht1_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn prefetcht2_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psadbw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psadbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psadbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psadbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufhw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufhw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshuflw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshuflw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufw_MmRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pshufw_MmRegister_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: MmRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psignw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pslldq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psllw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrad_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psraw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x72);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrld_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD2);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrldq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x73);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD3);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_MmRegister_Immediate8Bit(&mut self, arg0: MmRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x71);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psrlw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD1);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFA);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xFB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xE9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusb_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusb_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD8);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubusw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xD9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn psubw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xF9);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ptest_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ptest_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x38, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhbw_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x68);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x68);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x68);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x68);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhdq_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhdq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhqdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhqdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhwd_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckhwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x69);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklbw_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklbw_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklbw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckldq_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckldq_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckldq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpckldq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklqdq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklqdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x6C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklwd_MmRegister_Any32BitMemory(&mut self, arg0: MmRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklwd_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklwd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn punpcklwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_FS(&mut self, arg0: FS)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_GS(&mut self, arg0: GS)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xA8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_1_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x50, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xFF);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn push_1_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x50, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushf(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushfq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushq_Immediate16Bit(&mut self, arg0: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x68);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushq_Immediate32Bit(&mut self, arg0: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x68);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushq_Immediate8Bit(&mut self, arg0: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushw_Immediate16Bit(&mut self, arg0: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x68);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pushw_Immediate8Bit(&mut self, arg0: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x6A);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pxor_MmRegister_Any64BitMemory(&mut self, arg0: MmRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pxor_MmRegister_MmRegister(&mut self, arg0: MmRegister, arg1: MmRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pxor_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn pxor_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xEF);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcl_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcpps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcpps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcpss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcpss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rcr_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdfsbase_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdfsbase_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdgsbase_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdgsbase_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdrand_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdrand_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rdrand_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xC7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_ins_Any16BitMemory_DX(&mut self, arg0: Any16BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_ins_Any32BitMemory_DX(&mut self, arg0: Any32BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_ins_Any64BitMemory_DX(&mut self, arg0: Any64BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0x6D);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_ins_Any8BitMemory_DX(&mut self, arg0: Any8BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_ins_1_Any8BitMemory_DX(&mut self, arg0: Any8BitMemory, arg1: DX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0x6C);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_lods_AL(&mut self, arg0: AL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_lods_1_AL(&mut self, arg0: AL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAC);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_lods_AX(&mut self, arg0: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_lods_EAX(&mut self, arg0: EAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_lods_RAX(&mut self, arg0: RAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_movs_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_movs_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_movs_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_movs_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_movs_1_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA4);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_outs_DX_Any16BitMemory(&mut self, arg0: DX, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_outs_DX_Any32BitMemory(&mut self, arg0: DX, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_outs_DX_Any64BitMemory(&mut self, arg0: DX, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0x6F);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_outs_DX_Any8BitMemory(&mut self, arg0: DX, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0x6E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_outs_1_DX_Any8BitMemory(&mut self, arg0: DX, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0x6E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_stos_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_stos_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_stos_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_stos_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rep_stos_1_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_cmps_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_cmps_1_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_scas_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_scas_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_scas_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_scas_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repe_scas_1_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_cmps_Any16BitMemory_Any16BitMemory(&mut self, arg0: Any16BitMemory, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_cmps_Any32BitMemory_Any32BitMemory(&mut self, arg0: Any32BitMemory, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_cmps_Any64BitMemory_Any64BitMemory(&mut self, arg0: Any64BitMemory, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_cmps_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_cmps_1_Any8BitMemory_Any8BitMemory(&mut self, arg0: Any8BitMemory, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_scas_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_scas_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_scas_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_scas_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn repne_scas_1_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ret(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC3);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ret_Far(&mut self, arg0: Far)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ret_Immediate16Bit(&mut self, arg0: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC2);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ret_Immediate16Bit_Far(&mut self, arg0: Immediate16Bit, arg1: Far)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xCA);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rol_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ror_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rorx_Register32Bit_Any32BitMemory_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn rorx_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn rorx_Register64Bit_Any64BitMemory_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn rorx_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn roundpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundsd_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundsd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0B);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundss_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn roundss_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x3A, 0x0A);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rsqrtss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn rsqrtss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sahf(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x9E);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sal_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sar_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_7);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sarx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x2, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn sarx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x2, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn sarx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x2, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn sarx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x2, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn sbb_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x1C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x1D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x1D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x1B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x1D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sbb_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scas_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scas_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scas_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scas_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scasb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAE);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scasd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scasq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn scasw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAF);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seta_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seta_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seta_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setae_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setae_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setae_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setb_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setb_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setb_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setbe_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setbe_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setbe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setc_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setc_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sete_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sete_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sete_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setg_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setg_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setg_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setge_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setge_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setge_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setl_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setl_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setl_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setle_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setle_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setle_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setna_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setna_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setna_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x96);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnae_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnae_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnae_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x92);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnb_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnb_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnb_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnbe_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnbe_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnbe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x97);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnc_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnc_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnc_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x93);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setne_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setne_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setne_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setng_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setng_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setng_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9E);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnge_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnge_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnge_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9C);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnl_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnl_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnl_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9D);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnle_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnle_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnle_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9F);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setno_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x91);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setno_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x91);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setno_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x91);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnp_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnp_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnp_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setns_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x99);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setns_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x99);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setns_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x99);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnz_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnz_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setnz_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x95);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seto_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x90);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seto_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x90);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn seto_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x90);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setp_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setp_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setp_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpe_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpe_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpe_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9A);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpo_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpo_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setpo_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x9B);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sets_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x98);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sets_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x98);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sets_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x98);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setz_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setz_Register8Bit(&mut self, arg0: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn setz_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x94);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sfence(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0xAE, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shl_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any16BitMemory_Register16Bit_CL(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any16BitMemory_Register16Bit_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any32BitMemory_Register32Bit_CL(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any32BitMemory_Register32Bit_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any64BitMemory_Register64Bit_CL(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Any64BitMemory_Register64Bit_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register16Bit_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register32Bit_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register64Bit_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA5);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shld_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xA4);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shlx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shlx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shlx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shlx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shr_Any16BitMemory_CL(&mut self, arg0: Any16BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any16BitMemory_One(&mut self, arg0: Any16BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any32BitMemory_CL(&mut self, arg0: Any32BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any32BitMemory_One(&mut self, arg0: Any32BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any64BitMemory_CL(&mut self, arg0: Any64BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any64BitMemory_One(&mut self, arg0: Any64BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any8BitMemory_CL(&mut self, arg0: Any8BitMemory, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Any8BitMemory_One(&mut self, arg0: Any8BitMemory, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register16Bit_One(&mut self, arg0: Register16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register32Bit_One(&mut self, arg0: Register32Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register64Bit_One(&mut self, arg0: Register64Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register8Bit_CL(&mut self, arg0: Register8Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_Register8Bit_One(&mut self, arg0: Register8Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_RegisterHigh8BitsOf16Bit_CL(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shr_RegisterHigh8BitsOf16Bit_One(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: One)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any16BitMemory_Register16Bit_CL(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any16BitMemory_Register16Bit_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any32BitMemory_Register32Bit_CL(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any32BitMemory_Register32Bit_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any64BitMemory_Register64Bit_CL(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Any64BitMemory_Register64Bit_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register16Bit_Register16Bit_CL(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register16Bit_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register32Bit_Register32Bit_CL(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register32Bit_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register64Bit_Register64Bit_CL(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: CL)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAD);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrd_Register64Bit_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xAC);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shrx_Register32Bit_Any32BitMemory_Register32Bit(&mut self, arg0: Register32Bit, arg1: Any32BitMemory, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shrx_Register32Bit_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shrx_Register64Bit_Any64BitMemory_Register64Bit(&mut self, arg0: Register64Bit, arg1: Any64BitMemory, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shrx_Register64Bit_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x3, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn shufpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC6);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shufpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC6);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shufps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC6);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn shufps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xC6);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sqrtss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stc(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xF9);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn std(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFD);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sti(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xFB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stos_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stos_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stos_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stos_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stosb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAA);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stosd(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stosq(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn stosw(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xAB);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x2C);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x2D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x2D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x2D);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sub_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn subss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x5C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn swapgs(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn syscall(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x05);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sysenter(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x34);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sysexit(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x35);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sysexit_PrefixRexW(&mut self, arg0: PrefixRexW)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x0F, 0x35);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sysret(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x07);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn sysret_PrefixRexW(&mut self, arg0: PrefixRexW)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x0F, 0x07);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA9);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xA9);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x85);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xA9);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_0);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn test_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x84);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn tzcnt_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xBC);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ucomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ucomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ucomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ucomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn ud2(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x0B);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpckhpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpckhpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpckhps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpckhps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x15);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpcklpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpcklpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpcklps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn unpcklps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x14);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn vaddpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaddsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesdec_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesdec_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesdeclast_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesdeclast_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesenc_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesenc_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesenclast_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesenclast_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesimc_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaesimc_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaeskeygenassist_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vaeskeygenassist_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandnps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x55);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vandps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x54);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendpd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendpd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendpd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendpd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vblendvpd_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvpd_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvpd_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvpd_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvps_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvps_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvps_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vblendvps_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vbroadcastf128_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcasti128_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastsd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastsd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastss_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vbroadcastss_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmppd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmppd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmppd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmppd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpsd_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpsd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpss_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcmpss_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC2);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2pd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2pd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2ps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtdq2ps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2dq_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2dq_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2ps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2ps_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtpd2ps_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtph2ps_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtph2ps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtph2ps_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtph2ps_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2dq_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2dq_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2pd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2pd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2pd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2pd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2ph_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2ph_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2ph_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtps2ph_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2ss_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsd2ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2sd_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2sd_XMMRegister_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2sd_XMMRegister_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2ss_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2ss_XMMRegister_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtsi2ss_XMMRegister_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2sd_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvtss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttpd2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttpd2dq_XMMRegister_Any256BitMemory(&mut self, arg0: XMMRegister, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttpd2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttpd2dq_XMMRegister_YMM(&mut self, arg0: XMMRegister, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xE6);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttps2dq_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttps2dq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttps2dq_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttps2dq_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x5B);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttsd2si_Register32Bit_Any64BitMemory(&mut self, arg0: Register32Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttsd2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttsd2si_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttsd2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttss2si_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttss2si_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttss2si_Register64Bit_Any32BitMemory(&mut self, arg0: Register64Bit, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vcvttss2si_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdivss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdppd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x41);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdppd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x41);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdpps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdpps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdpps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vdpps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn verr_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn verr_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn verw_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn verw_Register16Bit(&mut self, arg0: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x00);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn vextractf128_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vextractf128_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x19);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vextracti128_Any128BitMemory_YMM_Immediate8Bit(&mut self, arg0: Any128BitMemory, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vextracti128_XMMRegister_YMM_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vextractps_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vextractps_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x98);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x99);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x99);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x99);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x99);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmadd231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x96);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmaddsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsub231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x97);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xA7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfmsubadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xB7);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmadd231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x9F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub132ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x9F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xAF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub213ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xAF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231pd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231pd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231pd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231pd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231sd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231sd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0xBF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vfnmsub231ss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xBF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherdpd_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x92);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherdpd_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x92);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherdps_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x92);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherdps_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x92);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherqpd_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x93);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherqpd_YMM_Any64BitMemory_YMM(&mut self, arg0: YMM, arg1: Any64BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x93);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherqps_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x93);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vgatherqps_1_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x93);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhaddps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vhsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x7D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinsertf128_YMM_YMM_Any128BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinsertf128_YMM_YMM_XMMRegister_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x18);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinserti128_YMM_YMM_Any128BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinserti128_YMM_YMM_XMMRegister_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinsertps_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vinsertps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vlddqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vlddqu_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF0);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vldmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, Self::R64S_2);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xF7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovpd_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovpd_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x2F);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovps_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovps_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaskmovps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmaxss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vminss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovapd_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovaps_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovd_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovd_XMMRegister_Register32Bit(&mut self, arg0: XMMRegister, arg1: Register32Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovddup_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovddup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovddup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovddup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqa_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovdqu_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7F);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovhlps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovhpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovhpd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovhps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovhps_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovlhps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovlpd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovlpd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovlps_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x13);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovlps_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskpd_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskpd_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskpd_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskpd_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskps_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskps_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskps_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovmskps_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x50);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntdq_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0xE7);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntdq_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0xE7);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntdqa_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntdqa_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2A);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntpd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntpd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntps_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovntps_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x1, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_1_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0xD6);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x1, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_1_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_XMMRegister_Register64Bit(&mut self, arg0: XMMRegister, arg1: Register64Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x6E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x7E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovq_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0xD6);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsd_Any64BitMemory_XMMRegister(&mut self, arg0: Any64BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsd_1_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovshdup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovshdup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovshdup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovshdup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsldup_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsldup_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsldup_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovsldup_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x12);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovss_Any32BitMemory_XMMRegister(&mut self, arg0: Any32BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovss_1_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovupd_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_Any128BitMemory_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_Any256BitMemory_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_1_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x10);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmovups_1_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x11);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmpsadbw_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x42);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmpsadbw_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x42);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmpsadbw_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x42);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmpsadbw_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x42);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vmulss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vorps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x56);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsb_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsb_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsb_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1C);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsw_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpabsw_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x1D);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackssdw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackssdw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackssdw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackssdw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpacksswb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpacksswb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpacksswb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpacksswb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackusdw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackusdw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackusdw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackusdw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x2B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackuswb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x67);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackuswb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x67);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackuswb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x67);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpackuswb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x67);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xED);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xED);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xED);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xED);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDC);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddusw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpaddw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFD);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpalignr_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpalignr_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpalignr_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpalignr_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpand_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpand_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpand_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpand_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpandn_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpandn_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpandn_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpandn_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE0);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpavgw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendvb_XMMRegister_XMMRegister_Any128BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vpblendvb_XMMRegister_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vpblendvb_YMM_YMM_Any256BitMemory_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vpblendvb_YMM_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x4C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		disp_imm!(self, arg3);
	
		}
	
	#[inline(always)]
	fn vpblendw_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendw_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendw_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpblendw_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastb_XMMRegister_Any8BitMemory(&mut self, arg0: XMMRegister, arg1: Any8BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x78);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastb_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x78);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastb_YMM_Any8BitMemory(&mut self, arg0: YMM, arg1: Any8BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x78);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastb_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x78);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastd_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x58);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x59);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastw_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x79);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x79);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastw_YMM_Any16BitMemory(&mut self, arg0: YMM, arg1: Any16BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x79);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpbroadcastw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x79);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpclmulqdq_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x44);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpclmulqdq_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x44);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x74);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x74);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x74);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x74);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x76);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x76);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x76);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x76);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x29);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x75);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x75);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x75);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpeqw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x75);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpestri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpestri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpestrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpestrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x64);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x64);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x64);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x64);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x66);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x66);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x66);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x66);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x37);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x37);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x37);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x37);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x65);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x65);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x65);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpgtw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x65);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpistri_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpistri_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x63);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpistrm_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpcmpistrm_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vperm2f128_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vperm2f128_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vperm2i128_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vperm2i128_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x36);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x36);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermilps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermq_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpermq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x1, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrb_Any8BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrb_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrb_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrd_Any32BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrd_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrq_Any64BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x1, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrq_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x1, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x16);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrw_Any16BitMemory_XMMRegister_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrw_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrw_1_Register32Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrw_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xC5);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpextrw_1_Register64Bit_XMMRegister_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg0, arg1);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherdd_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x90);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherdd_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x90);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherdq_XMMRegister_Any32BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any32BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x90);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherdq_YMM_Any32BitMemory_YMM(&mut self, arg0: YMM, arg1: Any32BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x90);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherqd_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x91);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherqd_1_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg2, arg1, arg0);
	
		opcode!(self, 0x91);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherqq_XMMRegister_Any64BitMemory_XMMRegister(&mut self, arg0: XMMRegister, arg1: Any64BitMemory, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x91);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpgatherqq_YMM_Any64BitMemory_YMM(&mut self, arg0: YMM, arg1: Any64BitMemory, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg2, arg1, arg0);
	
		opcode!(self, 0x91);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x02);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x03);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphaddw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x01);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphminposuw_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphminposuw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x41);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x06);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x07);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x07);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x07);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x07);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vphsubw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x05);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrb_XMMRegister_XMMRegister_Any8BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any8BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrb_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrd_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrd_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrq_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrq_XMMRegister_XMMRegister_Register64Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register64Bit, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrw_XMMRegister_XMMRegister_Any16BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any16BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC4);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpinsrw_XMMRegister_XMMRegister_Register32Bit_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Register32Bit, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC4);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x04);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaddwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovd_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovd_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg0, arg2);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovq_Any128BitMemory_XMMRegister_XMMRegister(&mut self, arg0: Any128BitMemory, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg0, arg2);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovq_Any256BitMemory_YMM_YMM(&mut self, arg0: Any256BitMemory, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg0, arg2);
	
		opcode!(self, 0x8E);
	
		self.mod_rm_sib(&mut self, arg0, arg2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaskmovq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x8C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxub_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxub_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxub_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxub_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDE);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxud_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxud_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxud_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxud_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3F);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmaxuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3E);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x38);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x39);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminub_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminub_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminub_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminub_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xDA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminud_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminud_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminud_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminud_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpminuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x3A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovmskb_Register32Bit_XMMRegister(&mut self, arg0: Register32Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovmskb_Register32Bit_YMM(&mut self, arg0: Register32Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovmskb_Register64Bit_XMMRegister(&mut self, arg0: Register64Bit, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovmskb_Register64Bit_YMM(&mut self, arg0: Register64Bit, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0xD7);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x21);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbq_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x22);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbw_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxbw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x20);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxdq_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxdq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x25);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x23);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovsxwq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x24);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbd_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbd_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbq_XMMRegister_Any16BitMemory(&mut self, arg0: XMMRegister, arg1: Any16BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbq_YMM_Any32BitMemory(&mut self, arg0: YMM, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbw_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbw_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbw_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxbw_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxdq_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxdq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxdq_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxdq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x35);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwd_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwd_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwq_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwq_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwq_YMM_Any64BitMemory(&mut self, arg0: YMM, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmovzxwq_YMM_XMMRegister(&mut self, arg0: YMM, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x34);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuldq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuldq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuldq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuldq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x28);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhrsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhrsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhrsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhrsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhuw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhuw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhuw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhuw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulhw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulld_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmulld_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x40);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmullw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmullw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmullw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmullw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD5);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuludq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuludq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuludq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpmuludq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF4);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpor_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpor_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpor_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpor_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsadbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsadbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsadbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsadbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF6);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x00);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufhw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufhw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufhw_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshufhw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x2, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshuflw_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshuflw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshuflw_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpshuflw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x3, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x70);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsignw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslld_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslldq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_7);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_7);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpslldq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_7);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_7);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllq_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllvq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x47);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_6);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_6);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsllw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_4);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_4);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_4);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_4);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrad_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsravd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsravd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsravd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsravd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x46);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_4);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_4);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_4);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_4);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsraw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x72);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrld_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD2);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrldq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrldq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_3);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_3);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x73);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlq_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD3);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlvq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x1, arg1, arg2, arg0);
	
		opcode!(self, 0x45);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg0, arg1, Self::R64S_2);
	
		opcode!(self, 0x71);
	
		self.mod_rm_sib(arg1, Self::R64S_2);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_YMM_YMM_Any128BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsrlw_YMM_YMM_XMMRegister(&mut self, arg0: YMM, arg1: YMM, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD1);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFA);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xFB);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubsw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xE9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusb_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusb_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusb_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusb_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD8);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubusw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xD9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpsubw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xF9);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vptest_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vptest_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vptest_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vptest_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x17);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x68);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x68);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x68);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x68);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6A);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhqdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhqdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhqdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhqdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6D);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckhwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x69);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklbw_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklbw_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklbw_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklbw_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x60);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckldq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckldq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckldq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpckldq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x62);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklqdq_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklqdq_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklqdq_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklqdq_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x6C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklwd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklwd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklwd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpunpcklwd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x61);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpxor_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpxor_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpxor_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vpxor_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xEF);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrcpss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x53);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundpd_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundpd_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundpd_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundpd_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x09);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundps_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: Any128BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundps_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundps_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: Any256BitMemory, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundps_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x08);
	
		self.mod_rm_sib(arg1, arg0);
	
		disp_imm!(self, arg2);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundsd_XMMRegister_XMMRegister_Any64BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundsd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0B);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundss_XMMRegister_XMMRegister_Any32BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vroundss_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x03, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x0A);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vrsqrtss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x52);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufpd_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufpd_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufpd_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufpd_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufps_XMMRegister_XMMRegister_Any128BitMemory_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufps_XMMRegister_XMMRegister_XMMRegister_Immediate8Bit(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufps_YMM_YMM_Any256BitMemory_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vshufps_YMM_YMM_YMM_Immediate8Bit(&mut self, arg0: YMM, arg1: YMM, arg2: YMM, arg3: Immediate8Bit)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0xC6);
	
		self.mod_rm_sib(arg2, arg0);
	
		disp_imm!(self, arg3);
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtpd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtpd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsqrtss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x51);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vstmxcsr_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(&mut self, arg0);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(&mut self, arg0);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg0, Self::R64S_3);
	
		opcode!(self, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubsd_XMMRegister_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubsd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x3, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubss_XMMRegister_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vsubss_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x2, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x5C);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestpd_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestpd_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0F);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestps_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vtestps_YMM_YMM(&mut self, arg0: YMM, arg1: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x02, 0x1, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x0E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vucomisd_XMMRegister_Any64BitMemory(&mut self, arg0: XMMRegister, arg1: Any64BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vucomisd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vucomiss_XMMRegister_Any32BitMemory(&mut self, arg0: XMMRegister, arg1: Any32BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg1);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg1);
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vucomiss_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0, arg1, arg0);
	
		opcode!(self, 0x2E);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpckhps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x15);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vunpcklps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x14);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorpd_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorpd_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorpd_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorpd_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x1, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorps_XMMRegister_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: Any128BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorps_XMMRegister_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister, arg2: XMMRegister)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorps_YMM_YMM_Any256BitMemory(&mut self, arg0: YMM, arg1: YMM, arg2: Any256BitMemory)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		self.pref_group2(arg2);
	
		// Prefix Group 3 is #UD for VEX.
	
		self.pref_group4(arg2);
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vxorps_YMM_YMM_YMM(&mut self, arg0: YMM, arg1: YMM, arg2: YMM)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, arg1, arg2, arg0);
	
		opcode!(self, 0x57);
	
		self.mod_rm_sib(arg2, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vzeroall(&mut self)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x1, 0x0, 0x0, Self::XMM0);
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn vzeroupper(&mut self)
	{
		// VEX-Encoded Instruction.
	
		// Prefix Group 1 is #UD for VEX.
	
		// No Prefix Group 2.
	
		// Prefix Group 3 is #UD for VEX.
	
		// No Prefix Group 4.
	
		self.vex(0x01, 0x0, 0x0, 0x0, Self::XMM0);
	
		opcode!(self, 0x77);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	
		// No VEX Immediate.
	}
	
	#[inline(always)]
	fn wait(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		self.pref_fwait(0x9B);
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		// No Opcode Bytes	// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn wrfsbase_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn wrfsbase_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_2);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn wrgsbase_Register32Bit(&mut self, arg0: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn wrgsbase_Register64Bit(&mut self, arg0: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_3);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xabort_Immediate8Bit(&mut self, arg0: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC6, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xacquire(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF2);
	
		// No REX Prefix.
	
		// No Opcode Bytes	// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x0F, 0xC1);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xadd_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x0F, 0xC0);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xbegin_Label(&mut self, arg0: Label)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC7, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		self.disp_label32(&mut self, arg0);
	
		}
	
	#[inline(always)]
	fn xbegin_Relative32Bit(&mut self, arg0: Relative32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xC7, 0xF8);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg0);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_AX_Register16Bit(&mut self, arg0: AX, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, 0x00);
	
		opcode!(self, 0x90, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_EAX_Register32Bit(&mut self, arg0: EAX, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, 0x00);
	
		opcode!(self, 0x90, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register16Bit_AX(&mut self, arg0: Register16Bit, arg1: AX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x90, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register32Bit_EAX(&mut self, arg0: Register32Bit, arg1: EAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x90, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x87);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register64Bit_RAX(&mut self, arg0: Register64Bit, arg1: RAX)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x90, arg0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_RAX_Register64Bit(&mut self, arg0: RAX, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, rex_w());
	
		opcode!(self, 0x90, arg1);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xchg_1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x86);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xend(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xD5);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xgetbv(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xD0);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xlat_Any8BitMemory(&mut self, arg0: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xlatb(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0xD7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xlatb_1(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0xD7);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__AL_Immediate8Bit(&mut self, arg0: AL, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x34);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__AX_Immediate16Bit(&mut self, arg0: AX, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x35);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__EAX_Immediate32Bit(&mut self, arg0: EAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x35);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any16BitMemory_Immediate16Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any16BitMemory_Immediate8Bit(&mut self, arg0: Any16BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any16BitMemory_Register16Bit(&mut self, arg0: Any16BitMemory, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any32BitMemory_Immediate32Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any32BitMemory_Immediate8Bit(&mut self, arg0: Any32BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any32BitMemory_Register32Bit(&mut self, arg0: Any32BitMemory, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any64BitMemory_Immediate32Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any64BitMemory_Immediate8Bit(&mut self, arg0: Any64BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any64BitMemory_Register64Bit(&mut self, arg0: Any64BitMemory, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any8BitMemory_Immediate8Bit(&mut self, arg0: Any8BitMemory, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any8BitMemory_Register8Bit(&mut self, arg0: Any8BitMemory, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Any8BitMemory_RegisterHigh8BitsOf16Bit(&mut self, arg0: Any8BitMemory, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register16Bit_Immediate16Bit(&mut self, arg0: Register16Bit, arg1: Immediate16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register16Bit_Immediate8Bit(&mut self, arg0: Register16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register16Bit_Any16BitMemory(&mut self, arg0: Register16Bit, arg1: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_Register16Bit_Register16Bit(&mut self, arg0: Register16Bit, arg1: Register16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register32Bit_Immediate32Bit(&mut self, arg0: Register32Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register32Bit_Immediate8Bit(&mut self, arg0: Register32Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register32Bit_Any32BitMemory(&mut self, arg0: Register32Bit, arg1: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_Register32Bit_Register32Bit(&mut self, arg0: Register32Bit, arg1: Register32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register64Bit_Immediate32Bit(&mut self, arg0: Register64Bit, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x81);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register64Bit_Immediate8Bit(&mut self, arg0: Register64Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x83);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register64Bit_Any64BitMemory(&mut self, arg0: Register64Bit, arg1: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, rex_w());
	
		opcode!(self, 0x31);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_Register64Bit_Register64Bit(&mut self, arg0: Register64Bit, arg1: Register64Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, rex_w());
	
		opcode!(self, 0x33);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register8Bit_Immediate8Bit(&mut self, arg0: Register8Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register8Bit_Any8BitMemory(&mut self, arg0: Register8Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_Register8Bit_Register8Bit(&mut self, arg0: Register8Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_Register8Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: Register8Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__RAX_Immediate32Bit(&mut self, arg0: RAX, arg1: Immediate32Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, rex_w());
	
		opcode!(self, 0x35);
	
		// No MOD R/M or SIB Bytes.
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__RegisterHigh8BitsOf16Bit_Immediate8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Immediate8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x80);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		disp_imm!(self, arg1);
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__RegisterHigh8BitsOf16Bit_Any8BitMemory(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Any8BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_RegisterHigh8BitsOf16Bit_Register8Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: Register8Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, arg1, 0x00);
	
		opcode!(self, 0x30);
	
		self.mod_rm_sib(&mut self, arg0, arg1);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xor__1_RegisterHigh8BitsOf16Bit_RegisterHigh8BitsOf16Bit(&mut self, arg0: RegisterHigh8BitsOf16Bit, arg1: RegisterHigh8BitsOf16Bit)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x32);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xorpd_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x57);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xorpd_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x57);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xorps_XMMRegister_Any128BitMemory(&mut self, arg0: XMMRegister, arg1: Any128BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(arg1);
	
		self.pref_group4(arg1);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x57);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xorps_XMMRegister_XMMRegister(&mut self, arg0: XMMRegister, arg1: XMMRegister)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg1, arg0, 0x00);
	
		opcode!(self, 0x0F, 0x57);
	
		self.mod_rm_sib(arg1, arg0);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrelease(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		self.pref_group1(0xF3);
	
		// No REX Prefix.
	
		// No Opcode Bytes	// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor64_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor64_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xrstor64_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_5);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave64_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave64_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsave64_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_4);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, 0x00);
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt64_Any16BitMemory(&mut self, arg0: Any16BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		self.pref_group3();
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt64_Any32BitMemory(&mut self, arg0: Any32BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xsaveopt64_Any64BitMemory(&mut self, arg0: Any64BitMemory)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		self.pref_group2(&mut self, arg0);
	
		self.pref_group4(&mut self, arg0);
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		rex!(self, arg0, rex_w());
	
		opcode!(self, 0x0F, 0xAE);
	
		self.mod_rm_sib(&mut self, arg0, Self::R64S_6);
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
	
	#[inline(always)]
	fn xtest(&mut self)
	{
		// Non-VEX-Encoded Instruction.
	
		// No FWAIT Prefix.
	
		// No Prefix Group 2.
	
		// No Prefix Group 4.
	
		// No Prefix Group 3.
	
		// No Prefix Group 1.
	
		// No REX Prefix.
	
		opcode!(self, 0x0F, 0x01, 0xD6);
	
		// No MOD R/M or SIB Bytes.
	
		// No Displacement/Immediate.
	
		// No label displacement.
	}
}
